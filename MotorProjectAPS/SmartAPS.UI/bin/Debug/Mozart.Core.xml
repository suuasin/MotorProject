<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Mozart.Core</name>
    </assembly>
    <members>
        <member name="T:System.Threading.Algorithms.ParallelAlgorithms">
            <summary>
            Provides parallelized algorithms for common operations.
            </summary>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Sort``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>Sorts an array in parallel.</summary>
            <typeparam name="T">Specifies the type of data in the array.</typeparam>
            <param name="array">The array to be sorted.</param>
            <param name="sequentialThreshold">a minimum length to use parallelism,
            over which using parallelism got better performance than the sequential version</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Sort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0},System.Int32)">
            <summary>Sorts an array in parallel.</summary>
            <typeparam name="T">Specifies the type of data in the array.</typeparam>
            <param name="array">The array to be sorted.</param>
            <param name="comparer">The comparer used to compare two elements during the sort operation.</param>
            <param name="sequentialThreshold">a minimum length to use parallelism,
            over which using parallelism got better performance than the sequential version</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Sort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Int32)">
            <summary>Sorts an array in parallel.</summary>
            <typeparam name="T">Specifies the type of data in the array.</typeparam>
            <param name="array">The array to be sorted.</param>
            <param name="index">The index at which to start the sort, inclusive.</param>
            <param name="length">The number of elements to be sorted, starting at the start index.</param>
            <param name="sequentialThreshold">a minimum length to use parallelism,
            over which using parallelism got better performance than the sequential version</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Sort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Collections.Generic.IComparer{``0},System.Int32)">
            <summary>Sorts an array in parallel.</summary>
            <typeparam name="T">Specifies the type of data in the array.</typeparam>
            <param name="array">The array to be sorted.</param>
            <param name="index">The index at which to start the sort, inclusive.</param>
            <param name="length">The number of elements to be sorted, starting at the start index.</param>
            <param name="comparer">The comparer used to compare two elements during the sort operation.</param>
            <param name="sequentialThreshold">a minimum length to use parallelism,
            over which using parallelism got better performance than the sequential version</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Filter``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
            <summary>Filters an input list, running a predicate over each element of the input.</summary>
            <typeparam name="T">Specifies the type of data in the list.</typeparam>
            <param name="input">The list to be filtered.</param>
            <param name="predicate">The predicate to use to determine which elements pass.</param>
            <returns>A new list containing all those elements from the input that passed the filter.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Filter``1(System.Collections.Generic.IList{``0},System.Threading.Tasks.ParallelOptions,System.Func{``0,System.Boolean})">
            <summary>Filters an input list, running a predicate over each element of the input.</summary>
            <typeparam name="T">Specifies the type of data in the list.</typeparam>
            <param name="input">The list to be filtered.</param>
            <param name="parallelOptions">Options to use for the execution of this filter.</param>
            <param name="predicate">The predicate to use to determine which elements pass.</param>
            <returns>A new list containing all those elements from the input that passed the filter.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.For(System.Int64,System.Int64,System.Action{System.Int64})">
            <summary>Executes a for loop in which iterations may run in parallel.</summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="body">The delegate that is invoked once per iteration.</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})">
            <summary>Executes a for loop in which iterations may run in parallel.</summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="options">A System.Threading.Tasks.ParallelOptions instance that configures the behavior of this operation.</param>
            <param name="body">The delegate that is invoked once per iteration.</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Range(System.Int64,System.Int64)">
            <summary>Creates an enumerable that iterates the range [fromInclusive, toExclusive).</summary>
            <param name="fromInclusive">The lower bound, inclusive.</param>
            <param name="toExclusive">The upper bound, exclusive.</param>
            <returns>The enumerable of the range.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.ForRange(System.Int32,System.Int32,System.Action{System.Int32,System.Int32})">
            <summary>Executes a for loop over ranges in which iterations may run in parallel. </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="body">The delegate that is invoked once per range.</param>
            <returns>A ParallelLoopResult structure that contains information on what portion of the loop completed.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.ForRange(System.Int32,System.Int32,System.Action{System.Int32,System.Int32,System.Threading.Tasks.ParallelLoopState})">
            <summary>Executes a for loop over ranges in which iterations may run in parallel. </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="body">The delegate that is invoked once per range.</param>
            <returns>A ParallelLoopResult structure that contains information on what portion of the loop completed.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.ForRange``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})">
            <summary>Executes a for loop over ranges in which iterations may run in parallel. </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="localInit">The function delegate that returns the initial state of the local data for each thread.</param>
            <param name="body">The delegate that is invoked once per range.</param>
            <param name="localFinally">The delegate that performs a final action on the local state of each thread.</param>
            <returns>A ParallelLoopResult structure that contains information on what portion of the loop completed.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.ForRange(System.Int64,System.Int64,System.Action{System.Int64,System.Int64})">
            <summary>Executes a for loop over ranges in which iterations may run in parallel. </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="body">The delegate that is invoked once per range.</param>
            <returns>A ParallelLoopResult structure that contains information on what portion of the loop completed.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.ForRange(System.Int64,System.Int64,System.Action{System.Int64,System.Int64,System.Threading.Tasks.ParallelLoopState})">
            <summary>Executes a for loop over ranges in which iterations may run in parallel. </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="body">The delegate that is invoked once per range.</param>
            <returns>A ParallelLoopResult structure that contains information on what portion of the loop completed.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.ForRange``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})">
            <summary>Executes a for loop over ranges in which iterations may run in parallel. </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="localInit">The function delegate that returns the initial state of the local data for each thread.</param>
            <param name="body">The delegate that is invoked once per range.</param>
            <param name="localFinally">The delegate that performs a final action on the local state of each thread.</param>
            <returns>A ParallelLoopResult structure that contains information on what portion of the loop completed.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.ForRange(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Int32})">
            <summary>Executes a for loop over ranges in which iterations may run in parallel. </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the behavior of this operation.</param>
            <param name="body">The delegate that is invoked once per range.</param>
            <returns>A ParallelLoopResult structure that contains information on what portion of the loop completed.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.ForRange(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Int32,System.Threading.Tasks.ParallelLoopState})">
            <summary>Executes a for loop over ranges in which iterations may run in parallel. </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the behavior of this operation.</param>
            <param name="body">The delegate that is invoked once per range.</param>
            <returns>A ParallelLoopResult structure that contains information on what portion of the loop completed.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.ForRange``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})">
            <summary>Executes a for loop over ranges in which iterations may run in parallel. </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="localInit">The function delegate that returns the initial state of the local data for each thread.</param>
            <param name="body">The delegate that is invoked once per range.</param>
            <param name="localFinally">The delegate that performs a final action on the local state of each thread.</param>
            <returns>A ParallelLoopResult structure that contains information on what portion of the loop completed.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.ForRange(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Int64})">
            <summary>Executes a for loop over ranges in which iterations may run in parallel. </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the behavior of this operation.</param>
            <param name="body">The delegate that is invoked once per range.</param>
            <returns>A ParallelLoopResult structure that contains information on what portion of the loop completed.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.ForRange(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Int64,System.Threading.Tasks.ParallelLoopState})">
            <summary>Executes a for loop over ranges in which iterations may run in parallel. </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the behavior of this operation.</param>
            <param name="body">The delegate that is invoked once per range.</param>
            <returns>A ParallelLoopResult structure that contains information on what portion of the loop completed.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.ForRange``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})">
            <summary>Executes a for loop over ranges in which iterations may run in parallel. </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="localInit">The function delegate that returns the initial state of the local data for each thread.</param>
            <param name="body">The delegate that is invoked once per range.</param>
            <param name="localFinally">The delegate that performs a final action on the local state of each thread.</param>
            <returns>A ParallelLoopResult structure that contains information on what portion of the loop completed.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Map``2(System.Collections.Generic.IList{``0},System.Func{``0,``1})">
            <summary>Executes a map operation, converting an input list into an output list, in parallel.</summary>
            <typeparam name="TInput">Specifies the type of the input data.</typeparam>
            <typeparam name="TOutput">Specifies the type of the output data.</typeparam>
            <param name="input">The input list to be mapped used the transform function.</param>
            <param name="transform">The transform function to use to map the input data to the output data.</param>
            <returns>The output data, transformed using the transform function.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Map``2(System.Collections.Generic.IList{``0},System.Threading.Tasks.ParallelOptions,System.Func{``0,``1})">
            <summary>Executes a map operation, converting an input list into an output list, in parallel.</summary>
            <typeparam name="TInput">Specifies the type of the input data.</typeparam>
            <typeparam name="TOutput">Specifies the type of the output data.</typeparam>
            <param name="input">The input list to be mapped used the transform function.</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the behavior of this operation.</param>
            <param name="transform">The transform function to use to map the input data to the output data.</param>
            <returns>The output data, transformed using the transform function.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Reduce``1(System.Collections.Generic.IList{``0},``0,System.Func{``0,``0,``0})">
            <summary>Reduces the input data using the specified aggregation operation.</summary>
            <typeparam name="T">Specifies the type of data being aggregated.</typeparam>
            <param name="input">The input data to be reduced.</param>
            <param name="seed">The seed to use to initialize the operation; this seed may be used multiple times.</param>
            <param name="associativeCommutativeOperation">The reduction operation.</param>
            <returns>The reduced value.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Reduce``1(System.Collections.Generic.IList{``0},System.Threading.Tasks.ParallelOptions,``0,System.Func{``0,``0,``0})">
            <summary>Reduces the input data using the specified aggregation operation.</summary>
            <typeparam name="T">Specifies the type of data being aggregated.</typeparam>
            <param name="input">The input data to be reduced.</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the behavior of this operation.</param>
            <param name="seed">The seed to use to initialize the operation; this seed may be used multiple times.</param>
            <param name="associativeCommutativeOperation">The reduction operation.</param>
            <returns>The reduced value.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Reduce``1(System.Int32,System.Int32,System.Func{System.Int32,``0},``0,System.Func{``0,``0,``0})">
            <summary>Reduces the input range using the specified aggregation operation.</summary>
            <typeparam name="T">Specifies the type of data being aggregated.</typeparam>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="mapOperation">The function used to retrieve the data to be reduced for a given index.</param>
            <param name="seed">The seed to use to initialize the operation; this seed may be used multiple times.</param>
            <param name="associativeCommutativeOperation">The reduction operation.</param>
            <returns>The reduced value.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Reduce``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{System.Int32,``0},``0,System.Func{``0,``0,``0})">
            <summary>Reduces the input range using the specified aggregation operation.</summary>
            <typeparam name="T">Specifies the type of data being aggregated.</typeparam>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the behavior of this operation.</param>
            <param name="mapOperation">The function used to retrieve the data to be reduced for a given index.</param>
            <param name="seed">The seed to use to initialize the operation; this seed may be used multiple times.</param>
            <param name="associativeCommutativeOperation">The reduction operation.</param>
            <returns>The reduced value.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Scan``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})">
            <summary>Computes a parallel prefix scan over the source enumerable using the specified function.</summary>
            <typeparam name="T">The type of the data in the source.</typeparam>
            <param name="source">The source data over which a prefix scan should be computed.</param>
            <param name="function">The function to use for the scan.</param>
            <returns>The results of the scan operation.</returns>
            <remarks>
            For very small functions, such as additions, an implementation targeted
            at the relevant type and operation will perform significantly better than
            this generalized implementation.
            </remarks>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Scan``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0},System.Boolean)">
            <summary>Computes a parallel prefix scan over the source enumerable using the specified function.</summary>
            <typeparam name="T">The type of the data in the source.</typeparam>
            <param name="source">The source data over which a prefix scan should be computed.</param>
            <param name="function">The function to use for the scan.</param>
            <param name="loadBalance">Whether to load-balance during process.</param>
            <returns>The results of the scan operation.</returns>
            <remarks>
            For very small functions, such as additions, an implementation targeted
            at the relevant type and operation will perform significantly better than
            this generalized implementation.
            </remarks>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.ScanInPlace``1(``0[],System.Func{``0,``0,``0})">
            <summary>Computes a parallel prefix scan in-place on an array using the specified function.</summary>
            <typeparam name="T">The type of the data in the source.</typeparam>
            <param name="data">The data over which a prefix scan should be computed. Upon exit, stores the results.</param>
            <param name="function">The function to use for the scan.</param>
            <returns>The results of the scan operation.</returns>
            <remarks>
            For very small functions, such as additions, an implementation targeted
            at the relevant type and operation will perform significantly better than
            this generalized implementation.
            </remarks>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.ScanInPlace``1(``0[],System.Func{``0,``0,``0},System.Boolean)">
            <summary>Computes a parallel prefix scan in-place on an array using the specified function.</summary>
            <typeparam name="T">The type of the data in the source.</typeparam>
            <param name="data">The data over which a prefix scan should be computed. Upon exit, stores the results.</param>
            <param name="function">The function to use for the scan.</param>
            <param name="loadBalance">Whether to load-balance during process.</param>
            <returns>The results of the scan operation.</returns>
            <remarks>
            For very small functions, such as additions, an implementation targeted
            at the relevant type and operation will perform significantly better than
            this generalized implementation.
            </remarks>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.InclusiveScanInPlaceSerial``1(``0[],System.Func{``0,``0,``0},System.Int32,System.Int32,System.Int32)">
            <summary>Computes a sequential prefix scan over the array using the specified function.</summary>
            <typeparam name="T">The type of the data in the array.</typeparam>
            <param name="arr">The data, which will be overwritten with the computed prefix scan.</param>
            <param name="function">The function to use for the scan.</param>
            <param name="arrStart">The start of the data in arr over which the scan is being computed.</param>
            <param name="arrLength">The length of the data in arr over which the scan is being computed.</param>
            <param name="skip">The inclusive distance between elements over which the scan is being computed.</param>
            <remarks>No parameter validation is performed.</remarks>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.ExclusiveScanInPlaceSerial``1(``0[],System.Func{``0,``0,``0},System.Int32,System.Int32)">
            <summary>Computes a sequential exclusive prefix scan over the array using the specified function.</summary>
            <param name="arr">The data, which will be overwritten with the computed prefix scan.</param>
            <param name="function">The function to use for the scan.</param>
            <param name="lowerBoundInclusive">The inclusive lower bound of the array at which to start the scan.</param>
            <param name="upperBoundExclusive">The exclusive upper bound of the array at which to end the scan.</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.InclusiveScanInPlaceWithLoadBalancingParallel``1(``0[],System.Func{``0,``0,``0},System.Int32,System.Int32,System.Int32)">
            <summary>Computes a parallel prefix scan over the array using the specified function.</summary>
            <typeparam name="T">The type of the data in the array.</typeparam>
            <param name="arr">The data, which will be overwritten with the computed prefix scan.</param>
            <param name="function">The function to use for the scan.</param>
            <param name="arrStart">The start of the data in arr over which the scan is being computed.</param>
            <param name="arrLength">The length of the data in arr over which the scan is being computed.</param>
            <param name="skip">The inclusive distance between elements over which the scan is being computed.</param>
            <remarks>No parameter validation is performed.</remarks>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.InclusiveScanInPlaceParallel``1(``0[],System.Func{``0,``0,``0})">
            <summary>Computes a parallel inclusive prefix scan over the array using the specified function.</summary>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Sort``1(``0[],System.Int32)">
            <summary>Sorts an array in parallel.</summary>
            <typeparam name="T">Specifies the type of data in the array.</typeparam>
            <param name="array">The array to be sorted.</param>
            <param name="sequentialThreshold">a minimum length to use parallelism,
            over which using parallelism got better performance than the sequential version</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Sort``1(``0[],System.Collections.Generic.IComparer{``0},System.Int32)">
            <summary>Sorts an array in parallel.</summary>
            <typeparam name="T">Specifies the type of data in the array.</typeparam>
            <param name="array">The array to be sorted.</param>
            <param name="comparer">The comparer used to compare two elements during the sort operation.</param>
            <param name="sequentialThreshold">a minimum length to use parallelism,
            over which using parallelism got better performance than the sequential version</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Sort``1(``0[],System.Int32,System.Int32,System.Int32)">
            <summary>Sorts an array in parallel.</summary>
            <typeparam name="T">Specifies the type of data in the array.</typeparam>
            <param name="array">The array to be sorted.</param>
            <param name="index">The index at which to start the sort, inclusive.</param>
            <param name="length">The number of elements to be sorted, starting at the start index.</param>
            <param name="sequentialThreshold">a minimum length to use parallelism,
            over which using parallelism got better performance than the sequential version</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0},System.Int32)">
            <summary>Sorts an array in parallel.</summary>
            <typeparam name="T">Specifies the type of data in the array.</typeparam>
            <param name="array">The array to be sorted.</param>
            <param name="index">The index at which to start the sort, inclusive.</param>
            <param name="length">The number of elements to be sorted, starting at the start index.</param>
            <param name="comparer">The comparer used to compare two elements during the sort operation.</param>
            <param name="sequentialThreshold">a minimum length to use parallelism,
            over which using parallelism got better performance than the sequential version</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Sort``2(``0[],``1[],System.Int32)">
            <summary>Sorts key/value arrays in parallel.</summary>
            <typeparam name="TKey">Specifies the type of the data in the keys array.</typeparam>
            <typeparam name="TValue">Specifies the type of the data in the items array.</typeparam>
            <param name="keys">The keys to be sorted.</param>
            <param name="items">The items to be sorted based on the corresponding keys.</param>
            <param name="sequentialThreshold">a minimum length to use parallelism,
            over which using parallelism got better performance than the sequential version</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0},System.Int32)">
            <summary>Sorts key/value arrays in parallel.</summary>
            <typeparam name="TKey">Specifies the type of the data in the keys array.</typeparam>
            <typeparam name="TValue">Specifies the type of the data in the items array.</typeparam>
            <param name="keys">The keys to be sorted.</param>
            <param name="items">The items to be sorted based on the corresponding keys.</param>
            <param name="comparer">The comparer used to compare two elements during the sort operation.</param>
            <param name="sequentialThreshold">a minimum length to use parallelism,
            over which using parallelism got better performance than the sequential version</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Int32)">
            <summary>Sorts key/value arrays in parallel.</summary>
            <typeparam name="TKey">Specifies the type of the data in the keys array.</typeparam>
            <typeparam name="TValue">Specifies the type of the data in the items array.</typeparam>
            <param name="keys">The keys to be sorted.</param>
            <param name="items">The items to be sorted based on the corresponding keys.</param>
            <param name="index">The index at which to start the sort, inclusive.</param>
            <param name="length">The number of elements to be sorted, starting at the start index.</param>
            <param name="sequentialThreshold">a minimum length to use parallelism,
            over which using parallelism got better performance than the sequential version</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0},System.Int32)">
            <summary>Sorts key/value arrays in parallel.</summary>
            <typeparam name="TKey">Specifies the type of the data in the keys array.</typeparam>
            <typeparam name="TValue">Specifies the type of the data in the items array.</typeparam>
            <param name="keys">The keys to be sorted.</param>
            <param name="items">The items to be sorted based on the corresponding keys.</param>
            <param name="index">The index at which to start the sort, inclusive.</param>
            <param name="length">The number of elements to be sorted, starting at the start index.</param>
            <param name="comparer">The comparer used to compare two elements during the sort operation.</param>
            <param name="sequentialThreshold">a minimum length to use parallelism,
            over which using parallelism got better performance than the sequential version</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.SpeculativeFor``1(System.Int32,System.Int32,System.Func{System.Int32,``0})">
            <summary>Executes a function for each value in a range, returning the first result achieved and ceasing execution.</summary>
            <typeparam name="TResult">The type of the data returned.</typeparam>
            <param name="fromInclusive">The start of the range, inclusive.</param>
            <param name="toExclusive">The end of the range, exclusive.</param>
            <param name="options">The options to use for processing the loop.</param>
            <param name="body">The function to execute for each element.</param>
            <returns>The result computed.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.SpeculativeFor``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{System.Int32,``0})">
            <summary>Executes a function for each value in a range, returning the first result achieved and ceasing execution.</summary>
            <typeparam name="TResult">The type of the data returned.</typeparam>
            <param name="fromInclusive">The start of the range, inclusive.</param>
            <param name="toExclusive">The end of the range, exclusive.</param>
            <param name="options">The options to use for processing the loop.</param>
            <param name="body">The function to execute for each element.</param>
            <returns>The result computed.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.SpeculativeForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Executes a function for each element in a source, returning the first result achieved and ceasing execution.</summary>
            <typeparam name="TSource">The type of the data in the source.</typeparam>
            <typeparam name="TResult">The type of the data returned.</typeparam>
            <param name="source">The input elements to be processed.</param>
            <param name="body">The function to execute for each element.</param>
            <returns>The result computed.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.SpeculativeForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``0,``1})">
            <summary>Executes a function for each element in a source, returning the first result achieved and ceasing execution.</summary>
            <typeparam name="TSource">The type of the data in the source.</typeparam>
            <typeparam name="TResult">The type of the data returned.</typeparam>
            <param name="source">The input elements to be processed.</param>
            <param name="options">The options to use for processing the loop.</param>
            <param name="body">The function to execute for each element.</param>
            <returns>The result computed.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.SpeculativeInvoke``1(System.Func{``0}[])">
            <summary>Invokes the specified functions, potentially in parallel, canceling outstanding invocations once one completes.</summary>
            <typeparam name="T">Specifies the type of data returned by the functions.</typeparam>
            <param name="functions">The functions to be executed.</param>
            <returns>A result from executing one of the functions.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.SpeculativeInvoke``1(System.Threading.Tasks.ParallelOptions,System.Func{``0}[])">
            <summary>Invokes the specified functions, potentially in parallel, canceling outstanding invocations once one completes.</summary>
            <typeparam name="T">Specifies the type of data returned by the functions.</typeparam>
            <param name="options">The options to use for the execution.</param>
            <param name="functions">The functions to be executed.</param>
            <returns>A result from executing one of the functions.</returns>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Wavefront(System.Int32,System.Int32,System.Int32,System.Int32,System.Action{System.Int32,System.Int32,System.Int32,System.Int32})">
            <summary>Process in parallel a matrix where every cell has a dependency on the cell above it and to its left.</summary>
            <param name="numRows">The number of rows in the matrix.</param>
            <param name="numColumns">The number of columns in the matrix.</param>
            <param name="numBlocksPerRow">Partition the matrix into this number of blocks along the rows.</param>
            <param name="numBlocksPerColumn">Partition the matrix into this number of blocks along the columns.</param>
            <param name="processBlock">The action to invoke for every block, supplied with the start and end indices of the rows and columns.</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.Wavefront(System.Int32,System.Int32,System.Action{System.Int32,System.Int32})">
            <summary>Process in parallel a matrix where every cell has a dependency on the cell above it and to its left.</summary>
            <param name="numRows">The number of rows in the matrix.</param>
            <param name="numColumns">The number of columns in the matrix.</param>
            <param name="processRowColumnCell">The action to invoke for every cell, supplied with the row and column indices.</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.ParallelWhile(System.Func{System.Boolean},System.Action)">
            <summary>Repeatedly executes an operation in parallel while the specified condition evaluates to true.</summary>
            <param name="condition">The condition to evaluate.</param>
            <param name="body">The loop body.</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.ParallelWhile(System.Threading.Tasks.ParallelOptions,System.Func{System.Boolean},System.Action)">
            <summary>Repeatedly executes an operation in parallel while the specified condition evaluates to true.</summary>
            <param name="parallelOptions">A ParallelOptions instance that configures the behavior of this operation.</param>
            <param name="condition">The condition to evaluate.</param>
            <param name="body">The loop body.</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.WhileNotEmpty``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Action{``0}})">
            <summary>Processes data in parallel, allowing the processing function to add more data to be processed.</summary>
            <typeparam name="T">Specifies the type of data being processed.</typeparam>
            <param name="initialValues">The initial set of data to be processed.</param>
            <param name="body">The operation to execute for each value.</param>
        </member>
        <member name="M:System.Threading.Algorithms.ParallelAlgorithms.WhileNotEmpty``1(System.Threading.Tasks.ParallelOptions,System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Action{``0}})">
            <summary>Processes data in parallel, allowing the processing function to add more data to be processed.</summary>
            <typeparam name="T">Specifies the type of data being processed.</typeparam>
            <param name="parallelOptions">A ParallelOptions instance that configures the behavior of this operation.</param>
            <param name="initialValues">The initial set of data to be processed.</param>
            <param name="body">The operation to execute for each value.</param>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioners.ChunkPartitioner">
            <summary>
            Partitions an enumerable into chunks based on user-supplied criteria.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioners.ChunkPartitioner.Create``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32,System.Int32})">
            <summary>Creates a partitioner that chooses the next chunk size based on a user-supplied function.</summary>
            <typeparam name="TSource">The type of the data being partitioned.</typeparam>
            <param name="source">The data being partitioned.</param>
            <param name="nextChunkSizeFunc">A function that determines the next chunk size based on the
            previous chunk size.</param>
            <returns>A partitioner.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioners.ChunkPartitioner.Create``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Creates a partitioner that always uses a user-specified chunk size.</summary>
            <typeparam name="TSource">The type of the data being partitioned.</typeparam>
            <param name="source">The data being partitioned.</param>
            <param name="chunkSize">The chunk size to be used.</param>
            <returns>A partitioner.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioners.ChunkPartitioner.Create``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>Creates a partitioner that chooses chunk sizes between the user-specified min and max.</summary>
            <typeparam name="TSource">The type of the data being partitioned.</typeparam>
            <param name="source">The data being partitioned.</param>
            <param name="minChunkSize">The minimum chunk size to use.</param>
            <param name="maxChunkSize">The maximum chunk size to use.</param>
            <returns>A partitioner.</returns>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioners.ChunkPartitioner`1">
            <summary>
            Partitions an enumerable into chunks based on user-supplied criteria.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioners.ChunkPartitioner`1.GetOrderablePartitions(System.Int32)">
            <summary>
            Partitions the underlying collection into the specified number of orderable partitions.
            </summary>
            <param name="partitionCount">The number of partitions to create.</param>
            <returns>An object that can create partitions over the underlying data source.</returns>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioners.ChunkPartitioner`1.SupportsDynamicPartitions">
            <summary>Gets whether additional partitions can be created dynamically.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioners.ChunkPartitioner`1.GetOrderableDynamicPartitions">
            <summary>
            Creates an object that can partition the underlying collection into a variable number of
            partitions.
            </summary>
            <returns>
            An object that can create partitions over the underlying data source.
            </returns>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioners.SingleItemPartitioner">
            <summary>Partitions a data source one item at a time.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.Create``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Creates a partitioner for an enumerable that partitions it one item at a time.</summary>
            <typeparam name="T">Specifies the type of data contained in the enumerable.</typeparam>
            <param name="source">The source enumerable to be partitioned.</param>
            <returns>The partitioner.</returns>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemEnumerablePartitioner`1">
            <summary>Partitions an enumerable one item at a time.</summary>
            <typeparam name="T">Specifies the type of data contained in the list.</typeparam>
        </member>
        <member name="F:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemEnumerablePartitioner`1._source">
            <summary>The enumerable to be partitioned.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemEnumerablePartitioner`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Initializes the partitioner.</summary>
            <param name="source">The enumerable to be partitioned.</param>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemEnumerablePartitioner`1.SupportsDynamicPartitions">
            <summary>Gets whether this partitioner supports dynamic partitioning (it does).</summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemEnumerablePartitioner`1.GetOrderableDynamicPartitions">
            <summary>Gets a list of the specified static number of partitions.</summary>
            <param name="partitionCount">The static number of partitions to create.</param>
            <returns>The list of created partitions ready to be iterated.</returns>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemEnumerablePartitioner`1.DynamicGenerator">
            <summary>Dynamically generates a partitions on a shared enumerator.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemEnumerablePartitioner`1.DynamicGenerator._sharedEnumerator">
            <summary>The source enumerator shared amongst all partitions.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemEnumerablePartitioner`1.DynamicGenerator._nextAvailablePosition">
            <summary>The next available position to be yielded.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemEnumerablePartitioner`1.DynamicGenerator._remainingPartitions">
            <summary>The number of partitions remaining to be disposed, potentially including this dynamic generator.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemEnumerablePartitioner`1.DynamicGenerator._disposed">
            <summary>Whether this dynamic partitioner has been disposed.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemEnumerablePartitioner`1.DynamicGenerator.#ctor(System.Collections.Generic.IEnumerator{`0},System.Boolean)">
            <summary>Initializes the dynamic generator.</summary>
            <param name="sharedEnumerator">The enumerator shared by all partitions.</param>
            <param name="requiresDisposal">Whether this generator will be disposed.</param>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemEnumerablePartitioner`1.DynamicGenerator.System#IDisposable#Dispose">
            <summary>Closes the shared enumerator if all other partitions have completed.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemEnumerablePartitioner`1.DynamicGenerator.GetEnumerator">
            <summary>Increments the number of partitions in use and returns a new partition.</summary>
            <returns>The new partition.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemEnumerablePartitioner`1.DynamicGenerator.GetEnumeratorCore">
            <summary>Creates a partition.</summary>
            <returns>The new partition.</returns>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemIListPartitioner`1">
            <summary>Partitions a list one item at a time.</summary>
            <typeparam name="T">Specifies the type of data contained in the list.</typeparam>
        </member>
        <member name="F:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemIListPartitioner`1._source">
            <summary>The list to be partitioned.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemIListPartitioner`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes the partitioner.</summary>
            <param name="source">The list to be partitioned.</param>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemIListPartitioner`1.SupportsDynamicPartitions">
            <summary>Gets whether this partitioner supports dynamic partitioning (it does).</summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemIListPartitioner`1.GetOrderablePartitions(System.Int32)">
            <summary>Gets a list of the specified static number of partitions.</summary>
            <param name="partitionCount">The static number of partitions to create.</param>
            <returns>The list of created partitions ready to be iterated.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemIListPartitioner`1.GetOrderableDynamicPartitions">
            <summary>Creates a dynamic partitioner for creating a dynamic number of partitions.</summary>
            <returns>The dynamic partitioner.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioners.SingleItemPartitioner.SingleItemIListPartitioner`1.GetOrderableDynamicPartitionsCore(System.Collections.Generic.IList{`0},System.Runtime.CompilerServices.StrongBox{System.Int32})">
            <summary>An enumerable that creates individual enumerators that all work together to partition the list.</summary>
            <param name="source">The list being partitioned.</param>
            <param name="nextIteration">An integer shared between partitions denoting the next available index in the source.</param>
            <returns>An enumerable that generates enumerators which participate in partitioning the list.</returns>
        </member>
        <member name="T:Mozart.Collections.BloomFilter`1">
            <summary>
            Bloom filter.
            </summary>
            <typeparam name="T">Item type </typeparam>
        </member>
        <member name="M:Mozart.Collections.BloomFilter`1.#ctor(System.Int32)">
            <summary>
            Creates a new Bloom filter, specifying an error rate of 1/capacity, using the optimal size for the underlying data structure based 
            on the desired capacity and error rate, as well as the optimal number of hash functions.
            A secondary hash function will be provided for you if your type T is either string or int. Otherwise an exception will be thrown.
            If you are not using these types please use the overload that supports custom hash functions.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added,
            but the error rate will exceed what is expected.</param>
        </member>
        <member name="M:Mozart.Collections.BloomFilter`1.#ctor(System.Int32,System.Single)">
            <summary>
            Creates a new Bloom filter, using the optimal size for the underlying data structure based on the desired capacity and error rate,
            as well as the optimal number of hash functions.
            A secondary hash function will be provided for you if your type T is either string or int. Otherwise an exception will be thrown.
            If you are not using these types please use the overload that supports custom hash functions.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added,
            but the error rate will exceed what is expected.</param>
            <param name="errorRate">The accepable false-positive rate (e.g., 0.01F = 1%)</param>
        </member>
        <member name="M:Mozart.Collections.BloomFilter`1.#ctor(System.Int32,Mozart.Collections.BloomFilter{`0}.HashFunction)">
            <summary>
            Creates a new Bloom filter, specifying an error rate of 1/capacity, using the optimal size for the underlying data structure based 
            on the desired capacity and error rate, as well as the optimal number of hash functions.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added,
            but the error rate will exceed what is expected.</param>
            <param name="hashFunction">The function to hash the input values. Do not use GetHashCode(). If it is null,
            and T is string or int a hash function will be provided for you.</param>
        </member>
        <member name="M:Mozart.Collections.BloomFilter`1.#ctor(System.Int32,System.Single,Mozart.Collections.BloomFilter{`0}.HashFunction)">
            <summary>
            Creates a new Bloom filter, using the optimal size for the underlying data structure based on the desired capacity and error rate, 
            as well as the optimal number of hash functions.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added,
            but the error rate will exceed what is expected.</param>
            <param name="errorRate">The accepable false-positive rate (e.g., 0.01F = 1%)</param>
            <param name="hashFunction">The function to hash the input values. Do not use GetHashCode(). If it is null, 
            and T is string or int a hash function will be provided for you.</param>
        </member>
        <member name="M:Mozart.Collections.BloomFilter`1.#ctor(System.Int32,System.Single,Mozart.Collections.BloomFilter{`0}.HashFunction,System.Int32,System.Int32)">
            <summary>
            Creates a new Bloom filter.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added,
            but the error rate will exceed what is expected.</param>
            <param name="errorRate">The accepable false-positive rate (e.g., 0.01F = 1%)</param>
            <param name="hashFunction">The function to hash the input values. Do not use GetHashCode(). If it is null, 
            and T is string or int a hash function will be provided for you.</param>
            <param name="m">The number of elements in the BitArray.</param>
            <param name="k">The number of hash functions to use.</param>
        </member>
        <member name="T:Mozart.Collections.BloomFilter`1.HashFunction">
            <summary>
            A function that can be used to hash input.
            </summary>
            <param name="input">The values to be hashed.</param>
            <returns>The resulting hash code.</returns>
        </member>
        <member name="P:Mozart.Collections.BloomFilter`1.Truthiness">
            <summary>
            The ratio of false to true bits in the filter. E.g., 1 true bit in a 10 bit filter means a truthiness of 0.1.
            </summary>
        </member>
        <member name="M:Mozart.Collections.BloomFilter`1.Add(`0)">
            <summary>
            Adds a new item to the filter. It cannot be removed.
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:Mozart.Collections.BloomFilter`1.Contains(`0)">
            <summary>
            Checks for the existance of the item in the filter for a given probability.
            </summary>
            <param name="item"> The item. </param>
            <returns> The <see cref="T:System.Boolean"/>. </returns>
        </member>
        <member name="M:Mozart.Collections.BloomFilter`1.BestK(System.Int32,System.Single)">
            <summary>
            The best k.
            </summary>
            <param name="capacity"> The capacity. </param>
            <param name="errorRate"> The error rate. </param>
            <returns> The <see cref="T:System.Int32"/>. </returns>
        </member>
        <member name="M:Mozart.Collections.BloomFilter`1.BestM(System.Int32,System.Single)">
            <summary>
            The best m.
            </summary>
            <param name="capacity"> The capacity. </param>
            <param name="errorRate"> The error rate. </param>
            <returns> The <see cref="T:System.Int32"/>. </returns>
        </member>
        <member name="M:Mozart.Collections.BloomFilter`1.BestErrorRate(System.Int32)">
            <summary>
            The best error rate.
            </summary>
            <param name="capacity"> The capacity. </param>
            <returns> The <see cref="T:System.Single"/>. </returns>
        </member>
        <member name="M:Mozart.Collections.BloomFilter`1.HashInt32(`0)">
            <summary>
            Hashes a 32-bit signed int using Thomas Wang's method v3.1 (http://www.concentric.net/~Ttwang/tech/inthash.htm).
            Runtime is suggested to be 11 cycles. 
            </summary>
            <param name="input">The integer to hash.</param>
            <returns>The hashed result.</returns>
        </member>
        <member name="M:Mozart.Collections.BloomFilter`1.HashString(`0)">
            <summary>
            Hashes a string using Bob Jenkin's "One At A Time" method from Dr. Dobbs (http://burtleburtle.net/bob/hash/doobs.html).
            Runtime is suggested to be 9x+9, where x = input.Length. 
            </summary>
            <param name="input">The string to hash.</param>
            <returns>The hashed result.</returns>
        </member>
        <member name="M:Mozart.Collections.BloomFilter`1.TrueBits">
            <summary>
            The true bits.
            </summary>
            <returns> The <see cref="T:System.Int32"/>. </returns>
        </member>
        <member name="M:Mozart.Collections.BloomFilter`1.ComputeHash(System.Int32,System.Int32,System.Int32)">
            <summary>
            Performs Dillinger and Manolios double hashing. 
            </summary>
            <param name="primaryHash"> The primary hash. </param>
            <param name="secondaryHash"> The secondary hash. </param>
            <param name="i"> The i. </param>
            <returns> The <see cref="T:System.Int32"/>. </returns>
        </member>
        <member name="M:Mozart.Collections.CountingBloomFilter`1.Remove(`0)">
            <summary>
            Removes the object from the counting bloom filter.
            </summary>
            <param name="item">element object to be deleted</param>
        </member>
        <member name="M:Mozart.Collections.CountingBloomFilter`1.GetEstimatedCount(`0)">
            <summary>
            Return the estimated count for an element using the Mininum Selection algorithm (i.e. by choosing the minimum
            counter for the given element). This estimation is biased, as it doest not consider how full the filter is, but
            performs best in practice. The underlying theoretical foundation are spectral Bloom filters, see:
            http://theory.stanford.edu/~matias/papers/sbf_thesis.pdf
            </summary>
            <param name="item">item to query</param>
            <returns>estimated count of the item</returns>
        </member>
        <member name="M:Mozart.Collections.CountingBloomFilter`1.Increment(System.Int32)">
            <summary>
              Increment the internal counter upon insertion of new elements.
            </summary>
            <param name="index">position at which to increase</param>
            <returns>the new counter value</returns>
        </member>
        <member name="M:Mozart.Collections.CountingBloomFilter`1.Decrement(System.Int32)">
            <summary>
            Decrements the internal counter upon deletion and unsets the Bloom filter bit if necessary.
            </summary>
            <param name="index">position at which to decrease</param>
            <returns>the new counter value</returns>
        </member>
        <member name="T:Mozart.Collections.InnerCollectionView`1">
            <summary>
            An inner class that functions as a view of an ICollection within a Multi-Value Dictionary
            </summary>
        </member>
        <member name="F:Mozart.Collections.InnerCollectionArray`1.Count">
            <summary>
            The number of values. Always at least 1 except in a dummy version for lookups.
            </summary>
        </member>
        <member name="F:Mozart.Collections.InnerCollectionArray`1.Values">
            <summary>
            An array of values. 
            </summary>
        </member>
        <member name="M:Mozart.Collections.InnerCollectionArray`1.#ctor">
            <summary>
            Create a dummy KeyAndValues with just the key, for lookups.
            </summary>
            <param name="key">The key to use.</param>
        </member>
        <member name="M:Mozart.Collections.InnerCollectionArray`1.Clone">
            <summary>
            Make a copy of a InnerCollectionArray, copying the array.
            </summary>
            <param name="x">KeyAndValues to copy.</param>
            <returns>A copied version.</returns>
        </member>
        <member name="M:Mozart.Collections.InnerCollectionArray`1.AllValues">
            <summary>
            Returned the whole value in current node.
            </summary>
            <returns>a yield value in current node.</returns>
        </member>
        <member name="T:Mozart.Collections.MultiTrie`1">
            <summary>
            The MultiTrie class that uses string set sorte as a single key.
            </summary>
            <typeparam name="T">Target type.</typeparam>
            <remarks>
            The data structre that stores data sorted as Key and Value paire
            1. Multiple valuse stored in one key.
            2. Stored values are sorted in Trie structure
            3. The next string is accessed through by accessing IEnumerartor.
            </remarks>
            
        </member>
        <member name="F:Mozart.Collections.MultiTrie`1.newCollectionFactory">
            <summary>
            The function to construct a new <see cref="T:System.Collections.Generic.ICollection`1"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Mozart.Collections.MultiTrie`1.#ctor(System.Boolean)">
            <summary>
            Create a new MultiTrie. 
            </summary>
            <remarks>
            The default ordering of keys and values will be used, as defined by TKey and TValue's implementation
            of IComparable&lt;T&gt; (or IComparable if IComparable&lt;T&gt; is not implemented).
            If a different ordering should be used,
            other constructors allow a custom Comparer or IComparer to be passed to changed the ordering.
            An exception occured by TKey or TValue does not implement either IComparable&lt;T&gt; or IComparable.
            </remarks>
        </member>
        <member name="M:Mozart.Collections.MultiTrie`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Boolean)">
            <summary>
            Create a new MultiDictionary. 
            </summary>
            <param name="valueEqualityComparer">An IEqualityComparer&lt;TValue&gt; instance that will be used to compare values.</param>
        </member>
        <member name="M:Mozart.Collections.MultiTrie`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},Mozart.Collections.Trie{Mozart.Collections.InnerCollectionView{`0}})">
            <summary>
            Create a new MultiDictionary. 
            </summary>
            <param name="valueEqualityComparer">An IEqualityComparer&lt;TValue&gt; instance that will be used to compare values.</param>
            <param name="trie">The value to change for current trie</param>
        </member>
        <member name="M:Mozart.Collections.MultiTrie`1.Add(System.String,`0)">
            <summary>
            <para>
            Adds a new value to be associated with a key. If duplicate values are permitted, this
            method always adds a new key-value pair to the dictionary.
            </para>
            </summary>
            <param name="key">The key to associate with.</param>
            <param name="value">The value to associated with <paramref name="key"/>.</param>
            <remarks>
            <para>
            If duplicate values are not permitted, and <paramref name="key"/> already has a value
            equal to <paramref name="value"/> associated with it, then that value is replaced with <paramref name="value"/>,
            and the number of values associate with <paramref name="key"/> is unchanged.
            </para>
            </remarks>
        </member>
        <member name="M:Mozart.Collections.MultiTrie`1.Remove(System.String,`0)">
            <summary>
            Removes a given value from the values associated with a key.
            </summary>
            <param name="key">A key to remove a value from.</param>
            <param name="value">The value to remove.</param>
            <remarks>
             If the last value is removed from a key, the key is removed also.
            </remarks>
            <returns>True if <paramref name="value"/> was associated with <paramref name="key"/> (and was
            therefore removed). False if <paramref name="value"/> was not associated with <paramref name="key"/>.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiTrie`1.Remove(System.String)">
            <summary>
            Removes a key and all associated values from the dictionary.
            </summary>
            <param name="key">The key to remove.</param>
            <remarks>
            If the key is not present in the dictionary, it is unchanged and false is returned.
            </remarks>
            <returns>
            True if the key was present and was removed. Returns false if the key was not present.
            </returns>
        </member>
        <member name="M:Mozart.Collections.MultiTrie`1.Clear">
            <summary>
            Removes all keys and values from the dictionary.
            </summary>
        </member>
        <member name="P:Mozart.Collections.MultiTrie`1.ValueComparer">
            <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare values in this dictionary. 
            </summary>
            <remarks>
            If the dictionary was created using a comparer, that comparer is returned. Otherwise
            the default comparer for T (EqualityComparer&lt;T&gt;.Default) is returned.
            </remarks>
        </member>
        <member name="P:Mozart.Collections.MultiTrie`1.Count">
            <summary>
            Gets the number of key-value pairs in the dictionary. Each value associated
            with a given key is counted.
            </summary>
            <remarks>
            If duplicate values are permitted, each duplicate value is included in the count.
            The number of key-value pairs in the dictionary.
            </remarks>
        </member>
        <member name="M:Mozart.Collections.MultiTrie`1.Contains(System.String,`0)">
            <summary>
            Checks to see if <paramref name="value"/> is associated with <paramref name="key"/>
            in the dictionary.
            </summary>
            <param name="key">The key to check.</param>
            <param name="value">The value to check.</param>
            <returns>True if <paramref name="value"/> is associated with <paramref name="key"/>.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiTrie`1.ContainsKey(System.String)">
            <summary>
            Checks to see if the key is present in the dictionary and has at least one value associated with it.
            </summary>
            <param name="key">The key to check.</param>
            <returns>
            True if <paramref name="key"/> is present and has at least
            one value associated with it. Returns false otherwise.
            </returns>
        </member>
        <member name="M:Mozart.Collections.MultiTrie`1.EqualValues(`0,`0)">
            <summary>
            Determine if two values are equal.
            </summary>
            <param name="value1">First value to compare.</param>
            <param name="value2">Second value to compare.</param>
            <returns>True if the values are equal.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiTrie`1.EnumerateKeys">
            <summary>
            Enumerate all the keys in the dictionary. 
            </summary>
            <returns>
            An IEnumerator&lt;string&gt; that enumerates all of the keys in the dictionary that
            have at least one value associated with them.
            </returns>
        </member>
        <member name="M:Mozart.Collections.MultiTrie`1.TryEnumerateValues(System.String,System.Collections.Generic.IEnumerator{`0}@)">
            <summary>
            Determines if this dictionary contains a key equal to <paramref name="key"/>.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="values">Returns all values associated with key, if true was returned.</param>
            <remarks>
            If so, all the values associated with that key are returned through the values parameter. 
            </remarks>
            <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiTrie`1.CountValues(System.String)">
            <summary>
            Gets the number of values associated with a given key.
            </summary>
            <param name="key">The key to count values of.</param>
            <returns>
            The number of values associated with <paramref name="key"/>. If <paramref name="key"/>
            is not present in the dictionary, zero is returned.
            </returns>
        </member>
        <member name="M:Mozart.Collections.MultiTrie`1.EnumerateValues(Mozart.Collections.InnerCollectionView{`0})">
            <summary>
            Enumerate the values in the a KeyAndValues structure.
            </summary>
            <param name="keyAndValues">Item with the values to enumerate.</param>
            <remarks>
            Can't return the array directly because:
            1. The array might be larger than the count.
            2. We can't allow clients to down-cast to the array and modify it.
            3. We have to abort enumeration if the hash changes.
            </remarks>
            <returns>
            An enumerable that enumerates the items in the KeyAndValues structure.
            </returns>
        </member>
        <member name="M:Mozart.Collections.MultiTrie`1.CheckEnumerationStamp(System.Int32)">
            <summary>
            Checks the given stamp against the current change stamp.
            </summary>
            <param name="startStamp">changeStamp at the start of the enumeration.</param>
            <remarks>
            If different, the collection has changed during enumeration and an InvalidOperationException must be thrown
            </remarks>
        </member>
        <member name="M:Mozart.Collections.MultiTrie`1.System#ICloneable#Clone">
            <summary>
            Implements ICloneable.Clone. Makes a shallow clone of this dictionary
            </summary>
            <remarks>
            if keys or values are reference types, then they are not cloned.
            </remarks>
            <returns>The cloned dictionary.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiTrie`1.Clone">
            <summary>
            Makes a shallow clone of this dictionary
            </summary>
            <remarks>
            if keys or values of the dictionary are reference types, then they are not cloned.
            If string or T is a value type, then each element is copied as if by simple assignment.
            Cloning the dictionary takes time O(N), where N is the number of key-value pairs in the dictionary.
            </remarks>
            <returns>The cloned dictionary.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiTrie`1.CloneContents">
            <summary>
            Makes a deep clone of this dictionary. A new dictionary is created with a clone of
            each entry of this dictionary, by calling ICloneable.Clone on each element.
            </summary>
            <remarks>
            If string or T is a value type, then each element is copied as if by simple assignment.
            <para>If string or T is a reference type, it must implement ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
            <para>Cloning the dictionary takes time O(N log N), where N is the number of key-value pairs in the dictionary.</para>
            </remarks>
            <returns>The cloned dictionary.</returns>
            <exception cref="T:System.InvalidOperationException">string or T is a reference type that does not implement ICloneable.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Mozart.Collections.MultiTrie`1.FindAny(System.String,System.Boolean)" -->
        <member name="M:Mozart.Collections.PatriciaTrieNode`1.#ctor(Mozart.Collections.PatriciaTrieNode{`0}.StringPartition,`0,Mozart.Collections.SimpleHashtable{System.Char,Mozart.Collections.PatriciaTrieNode{`0}})">
            <summary>
            Create a new node
            </summary>
            <param name="parent">The parent of the new node</param>
            <param name="key">The string partition for this node</param>
        </member>
        <member name="P:Mozart.Collections.PatriciaTrieNode`1.IsEmpty">
            <summary>
            Are there children of this node?
            </summary>
        </member>
        <member name="P:Mozart.Collections.PatriciaTrieNode`1.Parent">
            <summary>
            Get the parent of this node
            </summary>
        </member>
        <member name="P:Mozart.Collections.PatriciaTrieNode`1.Chars">
            <summary>
            Gets the char associated with this node.
            </summary>
        </member>
        <member name="P:Mozart.Collections.PatriciaTrieNode`1.Value">
            <summary>
            The value associated with this node
            </summary>
        </member>
        <member name="P:Mozart.Collections.PatriciaTrieNode`1.Key">
            <summary>
            Retrive the full key for this node, traversing parent-ward toward the root.
            </summary>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrieNode`1.Add(Mozart.Collections.PatriciaTrieNode{`0}.StringPartition,`0)">
            <summary>
            Adds a child to this node.
            </summary>
            <param name="key">The key for the child.</param>
            <returns>The child noded added to this node.</returns>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrieNode`1.Remove(Mozart.Collections.PatriciaTrieNode{`0}.StringPartition,System.Boolean)">
            <summary>
            Remove the child at the given byte
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrieNode`1.GetEnumerator">
            <summary>
            Iterates over the child nodes.
            </summary>
            <returns>An IEnumerator to parse over the child nodes.</returns>
        </member>
        <member name="P:Mozart.Collections.SortDescriptor.PropertyName">
            <summary>
            Gets or sets the name of the property.
            </summary>
            <value>The name of the property.</value>
        </member>
        <member name="P:Mozart.Collections.SortDescriptor.Direction">
            <summary>
            Gets or sets the direction.
            </summary>
            <value>The direction.</value>
        </member>
        <member name="P:Mozart.Collections.SortDescriptor.PropertyIndex">
            <summary>
            Gets or sets the owner.
            </summary>
            <value>The owner.</value>
        </member>
        <member name="M:Mozart.Collections.SortDescriptor.OnPropertyChanged(System.String)">
            <summary>
            Raises the PropertyChanged event
            </summary>
            <param name="propertyName">The name of the property</param>
        </member>
        <member name="M:Mozart.Collections.SortDescriptor.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Raises the PropertyChanged event
            </summary>
            <param name="e">A <see cref="T:System.ComponentModel.PropertyChangedEventArgs"/> instance containing event data.</param>
        </member>
        <member name="T:Mozart.Collections.TrieKeyWalker`1">
            <summary>
            The method signature used by <see cref="!:Trie.Traverse(TrieKeyWalker,TrieNode,string)"/> when it encounters a key.
            </summary>
        </member>
        <member name="T:Mozart.Collections.TrieWalker`1">
            <summary>
            The method signature used by <see cref="!:Trie.Traverse(TrieWalker,TrieNode)"/> when it encounters a node.
            </summary>
        </member>
        <member name="T:Mozart.Collections.Trie`1">
            <summary>
            A trie is a tree structure that implements a radix search.
            Each node of the tree has a sub-node for each possible next byte.
            </summary>
        </member>
        <member name="F:Mozart.Collections.Trie`1.root">
            <summary>
            The root node of the trie.
            </summary>
        </member>
        <member name="F:Mozart.Collections.Trie`1.count">
            <summary>
            The number of nodes are in the trie
            </summary>
        </member>
        <member name="M:Mozart.Collections.Trie`1.#ctor">
            <summary>
            Creates an empty trie.
            </summary>
        </member>
        <member name="M:Mozart.Collections.Trie`1.#ctor(System.Boolean)">
            <summary>
            Create an empty trie
            </summary>
            <param name="nonWild"></param>
        </member>
        <member name="M:Mozart.Collections.Trie`1.FindNode(System.String,System.Boolean)">
            <summary>
            Find a node for a given key, somewhere under the root.
            </summary>
            <param name="key">The bytes to search for, where key[0] corresponds to a child node of the root.</param>
            <param name="create">Create nodes that don't exist, while searching.</param>
            <returns>The node if found. If the node doesn't exist and create is true, the node created; otherwise null.</returns>
        </member>
        <member name="M:Mozart.Collections.Trie`1.FindNode(System.String,Mozart.Collections.TrieNode{`0},System.Boolean)">
            <summary>
            Finds a node in the given sub-tree.
            </summary>
            <param name="key">The key to search on, where key[0] corresponds to a child of startAt.</param>
            <param name="startAt">The node to search under</param>
            <param name="create">Create nodes that don't exist, while searching.</param>
            <returns>The node if found. If the node doesn't exist and create is true, the node created; otherwise null.</returns>
        </member>
        <member name="F:Mozart.Collections.Trie`1.Stg.Node">
            <summary>
            The value of the Stg.
            </summary>
        </member>
        <member name="F:Mozart.Collections.Trie`1.Stg.Depth">
            <summary>
            The value of current depth in trie.
            </summary>
        </member>
        <member name="M:Mozart.Collections.Trie`1.Stg.#ctor(Mozart.Collections.TrieNode{`0},System.Int32)">
            <summary>
            
            </summary>
            <param name="tn"></param>
            <param name="d"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Mozart.Collections.Trie`1.FindAny(System.String,System.Boolean)" -->
        <member name="M:Mozart.Collections.Trie`1.Traverse(Mozart.Collections.TrieKeyWalker{`0})">
            <summary>
            Performs the given function on every element of the trie.
            </summary>
            <param name="w">The function to call</param>
            <param name="data">Extra data to pass along to the function.</param>
            <remarks>
            This is equivalent to Perl's map() operator.
            </remarks>
        </member>
        <member name="M:Mozart.Collections.Trie`1.Traverse(Mozart.Collections.TrieKeyWalker{`0},Mozart.Collections.TrieNode{`0},System.Text.StringBuilder)">
            <summary>
            Perform the given function on every element of the trie.
            </summary>
            <param name="w">The function to call</param>
            <param name="data">Extra data to pass along to the function.</param>
            <param name="current">What node are we currently on?</param>
            <param name="key">A stack holding the current key value</param>
            <remarks>
            This is equivalent to Perl's map() operator.
            </remarks>
        </member>
        <member name="M:Mozart.Collections.Trie`1.Traverse(Mozart.Collections.TrieWalker{`0})">
            <summary>
            Perform the given function on every element of the trie.
            </summary>
            <param name="w">The function to call</param>
            <param name="data">Extra data to pass along to the function.</param>
            <remarks>
            Don't keep track of the keys (slightly faster than the other Traverse() method).
            This is equivalent to Perl's map() operator.
            </remarks>
        </member>
        <member name="M:Mozart.Collections.Trie`1.Traverse(Mozart.Collections.TrieWalker{`0},Mozart.Collections.TrieNode{`0})">
            <summary>
            Perform the given function on every element of the trie.
            </summary>
            <param name="w">The function to call</param>
            <param name="data">Extra data to pass along to the function.</param>
            <param name="current">What node are we currently on?</param>
            <remarks>
            This is equivalent to Perl's map() operator.
            </remarks>
        </member>
        <member name="M:Mozart.Collections.Trie`1.TryGetValue(System.String,`0@)">
            <summary>
            Determines if this dictionary contains a key equal to <paramref name="key"/>. If so, all the values
            associated with that key are returned through the values parameter.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="values">Returns all values associated with key, if true was returned.</param>
            <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
        </member>
        <member name="P:Mozart.Collections.Trie`1.Item(System.String)">
            <summary>
            Retrieve the value associated with the given key.
            </summary>
        </member>
        <member name="P:Mozart.Collections.Trie`1.IsFixedSize">
            <summary>
            Always "false" for now.
            </summary>
        </member>
        <member name="P:Mozart.Collections.Trie`1.Keys">
            <summary>
            Get a list of all of the keys.  Hope this doesn't get called often, since it has to make copies
            of all of the possible keys.
            </summary>
        </member>
        <member name="P:Mozart.Collections.Trie`1.Values">
            <summary>
            Returns a collection containing all of the values.
            </summary>
        </member>
        <member name="M:Mozart.Collections.Trie`1.Remove(System.String)">
            <summary>
            Removes the node associated with the given key, along with all newly empty ancestors.
            </summary>
            <param name="key">Key to remove.</param>
            <returns>
            True if node was associated with key (and was therefore removed).
            False if node was not associated with key.
            </returns>
        </member>
        <member name="M:Mozart.Collections.Trie`1.GetEnumerator">
            <summary>
            Iterate the dictionary way.
            </summary>
            <returns>An IEnumerator to parse the whole node in trie.</returns>
        </member>
        <member name="M:Mozart.Collections.Trie`1.Clear">
            <summary>
            Deletes all nodes.
            </summary>
        </member>
        <member name="M:Mozart.Collections.Trie`1.Add(System.String,`0)">
            <summary>
            Add a new key/value pair.
            </summary>
            <param name="key">A key to add</param>
            <param name="value">A value to add</param>
        </member>
        <member name="M:Mozart.Collections.Trie`1.ContainsKey(System.String)">
            <summary>
            Is the given key in the trie?
            </summary>
            <param name="key">A key to check</param>
            <returns>
            The target key contained or not in current trie.
            </returns>
        </member>
        <member name="M:Mozart.Collections.Trie`1.CopyTo(System.Collections.Generic.KeyValuePair{System.String,`0}[],System.Int32)">
            <summary>
            Copies this item to target array as index position
            </summary>
            <param name="array">array to copied</param>
            <param name="index">which position to start copy</param>
        </member>
        <member name="P:Mozart.Collections.Trie`1.Count">
            <summary>
            How many values are stored?
            </summary>
            <remarks>
            [TIP]NOT how many nodes.
            </remarks>
        </member>
        <member name="P:Mozart.Collections.Trie`1.SyncRoot">
            <summary>
            Object to synchronize on, if in thread-safe mode
            </summary>
        </member>
        <member name="P:Mozart.Collections.Trie`1.IsReadOnly">
            <summary>
            Always "false" for now
            </summary>
        </member>
        <member name="P:Mozart.Collections.Trie`1.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the trie is synchronized in thread-safe mode.
            Only returns false now.
            </summary>
        </member>
        <member name="M:Mozart.Collections.Trie`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            대상 array의 index 위치부터 현재 Trie 정보를 추가합니다.
            </summary>
            <param name="array">복사 대상 array 입니다.</param>
            <param name="index">복사 시작 위치 입니다.</param>
            <remarks>
            Array의 형식에 따라서 데이터를 복사합니다.
            1. keyValuePair, DictionaryEntry, object
            </remarks>
        </member>
        <member name="M:Mozart.Collections.Trie`1.TrieEnumerator.#ctor(Mozart.Collections.Trie{`0})">
            <summary>
            TrieEnumerator의 생성자 입니다. trie의 node값에 순차적으로 접근하기 위해 사용됩니다.
            </summary>
            <param name="Trie">대상 trie 입니다.</param>
            <remarks>
            trie 구조는 연관된 배열 또는 문자열의 정렬된 집합입니다.
            </remarks>
        </member>
        <member name="P:Mozart.Collections.Trie`1.TrieEnumerator.Current">
            <summary>
            현재 iterator 위치를 반환합니다.
            </summary>
        </member>
        <member name="M:Mozart.Collections.Trie`1.TrieEnumerator.Reset">
            <summary>
            현재 iterator 위치를 초기화하고, trie의 root로 이동합니다.
            </summary>
        </member>
        <member name="M:Mozart.Collections.Trie`1.TrieEnumerator.MoveNext">
            <summary>
            현재 iterator를 다음 문자열로 이동시킵니다.
            </summary>
            <returns>
            마지막 문자열인 경우 false, 아닌 경우 true를 반환합니다.
            </returns>
        </member>
        <member name="P:Mozart.Collections.Trie`1.TrieEnumerator.Key">
            <summary>
            현재 문자열의 key 입니다.
            </summary>
        </member>
        <member name="P:Mozart.Collections.Trie`1.TrieEnumerator.Value">
            <summary>
            현재 문자열 값 입니다.
            </summary>
        </member>
        <member name="P:Mozart.Collections.Trie`1.TrieEnumerator.Entry">
            <summary>
            DictionaryEntry 형식의 Trie node를 반환합니다.
            </summary>
        </member>
        <member name="P:Mozart.Collections.Trie`1.TrieEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            object형식의 현재 iterator를 반환합니다.
            </summary>
        </member>
        <member name="T:Mozart.Collections.TrieNode`1">
            <summary>
            A node in a Trie.  This class is public to support traversal via Trie.Traverse().
            </summary>
        </member>
        <member name="M:Mozart.Collections.TrieNode`1.#ctor(Mozart.Collections.TrieNode{`0},System.Char)">
            <summary>
            Create a new node
            </summary>
            <param name="parent">The parent of the new node</param>
            <param name="key">The byte for this node</param>
        </member>
        <member name="M:Mozart.Collections.TrieNode`1.Add(System.Char,System.Boolean)">
            <summary>
            Adds a child to this node.
            </summary>
            <param name="key">The key for the child.</param>
            <returns>The child noded added to this node.</returns>
        </member>
        <member name="P:Mozart.Collections.TrieNode`1.IsEmpty">
            <summary>
            Are there children of this node?
            </summary>
        </member>
        <member name="P:Mozart.Collections.TrieNode`1.Parent">
            <summary>
            Get the parent of this node
            </summary>
        </member>
        <member name="P:Mozart.Collections.TrieNode`1.Char">
            <summary>
            Gets the char associated with this node.
            </summary>
        </member>
        <member name="P:Mozart.Collections.TrieNode`1.Key">
            <summary>
            Retrive the full key for this node, traversing parent-ward toward the root.
            </summary>
        </member>
        <member name="P:Mozart.Collections.TrieNode`1.Value">
            <summary>
            The value associated with this node
            </summary>
        </member>
        <member name="P:Mozart.Collections.TrieNode`1.Item(System.Char,System.Boolean)">
            <summary>
            Gets the child associated with the specified byte, or null if one does not exist.
            </summary>
        </member>
        <member name="M:Mozart.Collections.TrieNode`1.GetOrCreate(System.Char,System.Boolean,System.Boolean)">
            <summary>
            Gets the child associated with the specified byte, or null if one does not exist.
            If create is true, a node will be added with a null value
            if a node does not already exist, so that this can be used
            as an lvalue.
            </summary>
        </member>
        <member name="M:Mozart.Collections.TrieNode`1.Remove(System.Char,System.Boolean)">
            <summary>
            Remove the child at the given byte
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Mozart.Collections.TrieNode`1.GetHashCode">
            <summary>
            Returns the hash code value for this map entry.
            </summary>
            <returns>Hash code.</returns>
        </member>
        <member name="M:Mozart.Collections.TrieNode`1.GetEnumerator">
            <summary>
            Iterates over the child nodes.
            </summary>
            <returns>An IEnumerator to parse over the child nodes.</returns>
        </member>
        <member name="T:Mozart.Collections.PatriciaTrieKeyWalker`1">
            <summary>
            The method signature used by <see cref="!:PatriciaTrie.Traverse(PatriciaTrieKeyWalker,PatriciaTrieNode,string)"/> when it encounters a key.
            </summary>
        </member>
        <member name="T:Mozart.Collections.PatriciaTrieWalker`1">
            <summary>
            The method signature used by <see cref="!:PatriciaTrie.Traverse(PatriciaTrieWalker,PatriciaTrieNode)"/> when it encounters a node.
            </summary>
        </member>
        <member name="T:Mozart.Collections.PatriciaTrie`1">
            <summary>
            A trie is a tree structure that implements a radix search.
            Each node of the tree has a sub-node for each possible next byte.
            </summary>
        </member>
        <member name="F:Mozart.Collections.PatriciaTrie`1.root">
            <summary>
            The root node of the trie.
            </summary>
        </member>
        <member name="F:Mozart.Collections.PatriciaTrie`1.count">
            <summary>
            The number of nodes are in the trie
            </summary>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrie`1.#ctor">
            <summary>
            Creates an empty trie.
            </summary>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrie`1.#ctor(System.Boolean)">
            <summary>
            Create an empty trie
            </summary>
            <param name="nonWild"></param>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrie`1.FindNode(System.String,System.Boolean)">
            <summary>
            Finds a node in the given sub-tree.
            </summary>
            <param name="key">The key to search on, where key[0] corresponds to a child of startAt.</param>
            <param name="startAt">The node to search under</param>
            <param name="create">Create nodes that don't exist, while searching.</param>
            <returns>The node if found. If the node doesn't exist and create is true, the node created; otherwise null.</returns>
        </member>
        <member name="F:Mozart.Collections.PatriciaTrie`1.Stg.Node">
            <summary>
            The value of the Stg.
            </summary>
        </member>
        <member name="F:Mozart.Collections.PatriciaTrie`1.Stg.Depth">
            <summary>
            The value of current depth in trie.
            </summary>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrie`1.Stg.#ctor(Mozart.Collections.PatriciaTrieNode{`0},System.Int32)">
            <summary>
            
            </summary>
            <param name="tn"></param>
            <param name="d"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Mozart.Collections.PatriciaTrie`1.FindAny(System.String,System.Boolean)" -->
        <member name="M:Mozart.Collections.PatriciaTrie`1.Traverse(Mozart.Collections.PatriciaTrieKeyWalker{`0})">
            <summary>
            Performs the given function on every element of the trie.
            </summary>
            <param name="w">The function to call</param>
            <param name="data">Extra data to pass along to the function.</param>
            <remarks>
            This is equivalent to Perl's map() operator.
            </remarks>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrie`1.Traverse(Mozart.Collections.PatriciaTrieKeyWalker{`0},Mozart.Collections.PatriciaTrieNode{`0},System.Text.StringBuilder)">
            <summary>
            Perform the given function on every element of the trie.
            </summary>
            <param name="w">The function to call</param>
            <param name="data">Extra data to pass along to the function.</param>
            <param name="current">What node are we currently on?</param>
            <param name="key">A stack holding the current key value</param>
            <remarks>
            This is equivalent to Perl's map() operator.
            </remarks>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrie`1.Traverse(Mozart.Collections.PatriciaTrieWalker{`0})">
            <summary>
            Perform the given function on every element of the trie.
            </summary>
            <param name="w">The function to call</param>
            <param name="data">Extra data to pass along to the function.</param>
            <remarks>
            Don't keep track of the keys (slightly faster than the other Traverse() method).
            This is equivalent to Perl's map() operator.
            </remarks>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrie`1.Traverse(Mozart.Collections.PatriciaTrieWalker{`0},Mozart.Collections.PatriciaTrieNode{`0})">
            <summary>
            Perform the given function on every element of the trie.
            </summary>
            <param name="w">The function to call</param>
            <param name="data">Extra data to pass along to the function.</param>
            <param name="current">What node are we currently on?</param>
            <remarks>
            This is equivalent to Perl's map() operator.
            </remarks>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrie`1.TryGetValue(System.String,`0@)">
            <summary>
            Determines if this dictionary contains a key equal to <paramref name="key"/>. If so, all the values
            associated with that key are returned through the values parameter.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="values">Returns all values associated with key, if true was returned.</param>
            <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
        </member>
        <member name="P:Mozart.Collections.PatriciaTrie`1.Item(System.String)">
            <summary>
            Retrieve the value associated with the given key.
            </summary>
        </member>
        <member name="P:Mozart.Collections.PatriciaTrie`1.IsFixedSize">
            <summary>
            Always "false" for now.
            </summary>
        </member>
        <member name="P:Mozart.Collections.PatriciaTrie`1.Keys">
            <summary>
            Get a list of all of the keys.  Hope this doesn't get called often, since it has to make copies
            of all of the possible keys.
            </summary>
        </member>
        <member name="P:Mozart.Collections.PatriciaTrie`1.Values">
            <summary>
            Returns a collection containing all of the values.
            </summary>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrie`1.Remove(System.String)">
            <summary>
            Removes the node associated with the given key, along with all newly empty ancestors.
            </summary>
            <param name="key">Key to remove.</param>
            <returns>
            True if node was associated with key (and was therefore removed).
            False if node was not associated with key.
            </returns>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrie`1.GetEnumerator">
            <summary>
            Iterate the dictionary way.
            </summary>
            <returns>An IEnumerator to parse the whole node in trie.</returns>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrie`1.Clear">
            <summary>
            Deletes all nodes.
            </summary>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrie`1.Add(System.String,`0)">
            <summary>
            Add a new key/value pair.
            </summary>
            <param name="key">A key to add</param>
            <param name="value">A value to add</param>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrie`1.ContainsKey(System.String)">
            <summary>
            Is the given key in the trie?
            </summary>
            <param name="key">A key to check</param>
            <returns>
            The target key contained or not in current trie.
            </returns>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrie`1.CopyTo(System.Collections.Generic.KeyValuePair{System.String,`0}[],System.Int32)">
            <summary>
            Copies this item to target array as index position
            </summary>
            <param name="array">array to copied</param>
            <param name="index">which position to start copy</param>
        </member>
        <member name="P:Mozart.Collections.PatriciaTrie`1.Count">
            <summary>
            How many values are stored?
            </summary>
            <remarks>
            [TIP]NOT how many nodes.
            </remarks>
        </member>
        <member name="P:Mozart.Collections.PatriciaTrie`1.SyncRoot">
            <summary>
            Object to synchronize on, if in thread-safe mode
            </summary>
        </member>
        <member name="P:Mozart.Collections.PatriciaTrie`1.IsReadOnly">
            <summary>
            Always "false" for now
            </summary>
        </member>
        <member name="P:Mozart.Collections.PatriciaTrie`1.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the trie is synchronized in thread-safe mode.
            Only returns false now.
            </summary>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrie`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            대상 array의 index 위치부터 현재 PatriciaTrie 정보를 추가합니다.
            </summary>
            <param name="array">복사 대상 array 입니다.</param>
            <param name="index">복사 시작 위치 입니다.</param>
            <remarks>
            Array의 형식에 따라서 데이터를 복사합니다.
            1. keyValuePair, DictionaryEntry, object
            </remarks>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrie`1.PatriciaTrieEnumerator.#ctor(Mozart.Collections.PatriciaTrie{`0})">
            <summary>
            PatriciaTrieEnumerator의 생성자 입니다. trie의 node값에 순차적으로 접근하기 위해 사용됩니다.
            </summary>
            <param name="PatriciaTrie">대상 trie 입니다.</param>
            <remarks>
            trie 구조는 연관된 배열 또는 문자열의 정렬된 집합입니다.
            </remarks>
        </member>
        <member name="P:Mozart.Collections.PatriciaTrie`1.PatriciaTrieEnumerator.Current">
            <summary>
            현재 iterator 위치를 반환합니다.
            </summary>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrie`1.PatriciaTrieEnumerator.Reset">
            <summary>
            현재 iterator 위치를 초기화하고, trie의 root로 이동합니다.
            </summary>
        </member>
        <member name="M:Mozart.Collections.PatriciaTrie`1.PatriciaTrieEnumerator.MoveNext">
            <summary>
            현재 iterator를 다음 문자열로 이동시킵니다.
            </summary>
            <returns>
            마지막 문자열인 경우 false, 아닌 경우 true를 반환합니다.
            </returns>
        </member>
        <member name="P:Mozart.Collections.PatriciaTrie`1.PatriciaTrieEnumerator.Key">
            <summary>
            현재 문자열의 key 입니다.
            </summary>
        </member>
        <member name="P:Mozart.Collections.PatriciaTrie`1.PatriciaTrieEnumerator.Value">
            <summary>
            현재 문자열 값 입니다.
            </summary>
        </member>
        <member name="P:Mozart.Collections.PatriciaTrie`1.PatriciaTrieEnumerator.Entry">
            <summary>
            DictionaryEntry 형식의 PatriciaTrie node를 반환합니다.
            </summary>
        </member>
        <member name="P:Mozart.Collections.PatriciaTrie`1.PatriciaTrieEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            object형식의 현재 iterator를 반환합니다.
            </summary>
        </member>
        <member name="T:Mozart.Collections.MultiPatriciaTrie`1">
            <summary>
            The MultiPatriciaTrie class that uses string set sorte as a single key.
            </summary>
            <typeparam name="T">Target type.</typeparam>
            <remarks>
            The data structre that stores data sorted as Key and Value paire
            1. Multiple valuse stored in one key.
            2. Stored values are sorted in PatriciaTrie structure
            3. The next string is accessed through by accessing IEnumerartor.
            </remarks>
            
        </member>
        <member name="F:Mozart.Collections.MultiPatriciaTrie`1.newCollectionFactory">
            <summary>
            The function to construct a new <see cref="T:System.Collections.Generic.ICollection`1"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Mozart.Collections.MultiPatriciaTrie`1.#ctor(System.Boolean)">
            <summary>
            Create a new MultiPatriciaTrie. 
            </summary>
            <remarks>
            The default ordering of keys and values will be used, as defined by TKey and TValue's implementation
            of IComparable&lt;T&gt; (or IComparable if IComparable&lt;T&gt; is not implemented).
            If a different ordering should be used,
            other constructors allow a custom Comparer or IComparer to be passed to changed the ordering.
            An exception occured by TKey or TValue does not implement either IComparable&lt;T&gt; or IComparable.
            </remarks>
        </member>
        <member name="M:Mozart.Collections.MultiPatriciaTrie`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Boolean)">
            <summary>
            Create a new MultiDictionary. 
            </summary>
            <param name="valueEqualityComparer">An IEqualityComparer&lt;TValue&gt; instance that will be used to compare values.</param>
        </member>
        <member name="M:Mozart.Collections.MultiPatriciaTrie`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},Mozart.Collections.PatriciaTrie{Mozart.Collections.InnerCollectionView{`0}})">
            <summary>
            Create a new MultiDictionary. 
            </summary>
            <param name="valueEqualityComparer">An IEqualityComparer&lt;TValue&gt; instance that will be used to compare values.</param>
            <param name="trie">The value to change for current trie</param>
        </member>
        <member name="M:Mozart.Collections.MultiPatriciaTrie`1.Add(System.String,`0)">
            <summary>
            <para>
            Adds a new value to be associated with a key. If duplicate values are permitted, this
            method always adds a new key-value pair to the dictionary.
            </para>
            </summary>
            <param name="key">The key to associate with.</param>
            <param name="value">The value to associated with <paramref name="key"/>.</param>
            <remarks>
            <para>
            If duplicate values are not permitted, and <paramref name="key"/> already has a value
            equal to <paramref name="value"/> associated with it, then that value is replaced with <paramref name="value"/>,
            and the number of values associate with <paramref name="key"/> is unchanged.
            </para>
            </remarks>
        </member>
        <member name="M:Mozart.Collections.MultiPatriciaTrie`1.Remove(System.String,`0)">
            <summary>
            Removes a given value from the values associated with a key.
            </summary>
            <param name="key">A key to remove a value from.</param>
            <param name="value">The value to remove.</param>
            <remarks>
             If the last value is removed from a key, the key is removed also.
            </remarks>
            <returns>True if <paramref name="value"/> was associated with <paramref name="key"/> (and was
            therefore removed). False if <paramref name="value"/> was not associated with <paramref name="key"/>.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiPatriciaTrie`1.Remove(System.String)">
            <summary>
            Removes a key and all associated values from the dictionary.
            </summary>
            <param name="key">The key to remove.</param>
            <remarks>
            If the key is not present in the dictionary, it is unchanged and false is returned.
            </remarks>
            <returns>
            True if the key was present and was removed. Returns false if the key was not present.
            </returns>
        </member>
        <member name="M:Mozart.Collections.MultiPatriciaTrie`1.Clear">
            <summary>
            Removes all keys and values from the dictionary.
            </summary>
        </member>
        <member name="P:Mozart.Collections.MultiPatriciaTrie`1.ValueComparer">
            <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare values in this dictionary. 
            </summary>
            <remarks>
            If the dictionary was created using a comparer, that comparer is returned. Otherwise
            the default comparer for T (EqualityComparer&lt;T&gt;.Default) is returned.
            </remarks>
        </member>
        <member name="P:Mozart.Collections.MultiPatriciaTrie`1.Count">
            <summary>
            Gets the number of key-value pairs in the dictionary. Each value associated
            with a given key is counted.
            </summary>
            <remarks>
            If duplicate values are permitted, each duplicate value is included in the count.
            The number of key-value pairs in the dictionary.
            </remarks>
        </member>
        <member name="M:Mozart.Collections.MultiPatriciaTrie`1.Contains(System.String,`0)">
            <summary>
            Checks to see if <paramref name="value"/> is associated with <paramref name="key"/>
            in the dictionary.
            </summary>
            <param name="key">The key to check.</param>
            <param name="value">The value to check.</param>
            <returns>True if <paramref name="value"/> is associated with <paramref name="key"/>.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiPatriciaTrie`1.ContainsKey(System.String)">
            <summary>
            Checks to see if the key is present in the dictionary and has at least one value associated with it.
            </summary>
            <param name="key">The key to check.</param>
            <returns>
            True if <paramref name="key"/> is present and has at least
            one value associated with it. Returns false otherwise.
            </returns>
        </member>
        <member name="M:Mozart.Collections.MultiPatriciaTrie`1.EqualValues(`0,`0)">
            <summary>
            Determine if two values are equal.
            </summary>
            <param name="value1">First value to compare.</param>
            <param name="value2">Second value to compare.</param>
            <returns>True if the values are equal.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiPatriciaTrie`1.EnumerateKeys">
            <summary>
            Enumerate all the keys in the dictionary. 
            </summary>
            <returns>
            An IEnumerator&lt;string&gt; that enumerates all of the keys in the dictionary that
            have at least one value associated with them.
            </returns>
        </member>
        <member name="M:Mozart.Collections.MultiPatriciaTrie`1.TryEnumerateValues(System.String,System.Collections.Generic.IEnumerator{`0}@)">
            <summary>
            Determines if this dictionary contains a key equal to <paramref name="key"/>.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="values">Returns all values associated with key, if true was returned.</param>
            <remarks>
            If so, all the values associated with that key are returned through the values parameter. 
            </remarks>
            <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiPatriciaTrie`1.CountValues(System.String)">
            <summary>
            Gets the number of values associated with a given key.
            </summary>
            <param name="key">The key to count values of.</param>
            <returns>
            The number of values associated with <paramref name="key"/>. If <paramref name="key"/>
            is not present in the dictionary, zero is returned.
            </returns>
        </member>
        <member name="M:Mozart.Collections.MultiPatriciaTrie`1.EnumerateValues(Mozart.Collections.InnerCollectionView{`0})">
            <summary>
            Enumerate the values in the a KeyAndValues structure.
            </summary>
            <param name="keyAndValues">Item with the values to enumerate.</param>
            <remarks>
            Can't return the array directly because:
            1. The array might be larger than the count.
            2. We can't allow clients to down-cast to the array and modify it.
            3. We have to abort enumeration if the hash changes.
            </remarks>
            <returns>
            An enumerable that enumerates the items in the KeyAndValues structure.
            </returns>
        </member>
        <member name="M:Mozart.Collections.MultiPatriciaTrie`1.CheckEnumerationStamp(System.Int32)">
            <summary>
            Checks the given stamp against the current change stamp.
            </summary>
            <param name="startStamp">changeStamp at the start of the enumeration.</param>
            <remarks>
            If different, the collection has changed during enumeration and an InvalidOperationException must be thrown
            </remarks>
        </member>
        <member name="M:Mozart.Collections.MultiPatriciaTrie`1.System#ICloneable#Clone">
            <summary>
            Implements ICloneable.Clone. Makes a shallow clone of this dictionary
            </summary>
            <remarks>
            if keys or values are reference types, then they are not cloned.
            </remarks>
            <returns>The cloned dictionary.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiPatriciaTrie`1.Clone">
            <summary>
            Makes a shallow clone of this dictionary
            </summary>
            <remarks>
            if keys or values of the dictionary are reference types, then they are not cloned.
            If string or T is a value type, then each element is copied as if by simple assignment.
            Cloning the dictionary takes time O(N), where N is the number of key-value pairs in the dictionary.
            </remarks>
            <returns>The cloned dictionary.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiPatriciaTrie`1.CloneContents">
            <summary>
            Makes a deep clone of this dictionary. A new dictionary is created with a clone of
            each entry of this dictionary, by calling ICloneable.Clone on each element.
            </summary>
            <remarks>
            If string or T is a value type, then each element is copied as if by simple assignment.
            <para>If string or T is a reference type, it must implement ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
            <para>Cloning the dictionary takes time O(N log N), where N is the number of key-value pairs in the dictionary.</para>
            </remarks>
            <returns>The cloned dictionary.</returns>
            <exception cref="T:System.InvalidOperationException">string or T is a reference type that does not implement ICloneable.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Mozart.Collections.MultiPatriciaTrie`1.FindAny(System.String,System.Boolean)" -->
        <member name="T:Mozart.Collections.CollectionBase`1">
            <summary>
            CollectionBase is a base class that can be used to more easily implement the
            generic ICollection&lt;T&gt; and non-generic ICollection interfaces.
            </summary>
            <remarks>
            <para>To use CollectionBase as a base class, the derived class must override
            the Count, GetEnumerator, Add, Clear, and Remove methods. </para>
            <para>ICollection&lt;T&gt;.Contains need not be implemented by the
            derived class, but it should be strongly considered, because the CollectionBase implementation
            may not be very efficient.</para>
            </remarks>
            <typeparam name="T">The item type of the collection.</typeparam>
        </member>
        <member name="M:Mozart.Collections.CollectionBase`1.ToString">
            <summary>
            Shows the string representation of the collection. The string representation contains
            a list of the items in the collection. Contained collections (except string) are expanded
            recursively.
            </summary>
            <returns>The string representation of the collection.</returns>
        </member>
        <member name="M:Mozart.Collections.CollectionBase`1.DebuggerDisplayString">
            <summary>
            Display the contents of the collection in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
            <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
        </member>
        <member name="M:Mozart.Collections.CollectionBase`1.Add(`0)">
            <summary>
            Must be overridden to allow adding items to this collection.
            </summary>
            <remarks><p>This method is not abstract, although derived classes should always
            override it. It is not abstract because some derived classes may wish to reimplement
            Add with a different return type (typically bool). In C#, this can be accomplished
            with code like the following:</p>
            <code>
                public class MyCollection&lt;T&gt;: CollectionBase&lt;T&gt;, ICollection&lt;T&gt;
                {
                    public new bool Add(T item) {
                        /* Add the item */
                    }
             
                    void ICollection&lt;T&gt;.Add(T item) {
                        Add(item);
                    }
                }
            </code>
            </remarks>
            <param name="item">Item to be added to the collection.</param>
            <exception cref="T:System.NotImplementedException">Always throws this exception to indicated
            that the method must be overridden or re-implemented in the derived class.</exception>
        </member>
        <member name="M:Mozart.Collections.CollectionBase`1.Clear">
            <summary>
            Must be overridden to allow clearing this collection.
            </summary>
        </member>
        <member name="M:Mozart.Collections.CollectionBase`1.Remove(`0)">
            <summary>
            Must be overridden to allow removing items from this collection.
            </summary>
            <returns>True if <paramref name="item"/> existed in the collection and
            was removed. False if <paramref name="item"/> did not exist in the collection.</returns>
        </member>
        <member name="M:Mozart.Collections.CollectionBase`1.Contains(`0)">
            <summary>
            Determines if the collection contains a particular item. This default implementation
            iterates all of the items in the collection via GetEnumerator, testing each item
            against <paramref name="item"/> using IComparable&lt;T&gt;.Equals or
            Object.Equals.
            </summary>
            <remarks>You should strongly consider overriding this method to provide
            a more efficient implementation, or if the default equality comparison
            is inappropriate.</remarks>
            <param name="item">The item to check for in the collection.</param>
            <returns>True if the collection contains <paramref name="item"/>, false otherwise.</returns>
        </member>
        <member name="M:Mozart.Collections.CollectionBase`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies all the items in the collection into an array. Implemented by
            using the enumerator returned from GetEnumerator to get all the items
            and copy them to the provided array.
            </summary>
            <param name="array">Array to copy to.</param>
            <param name="arrayIndex">Starting index in <paramref name="array"/> to copy to.</param>
        </member>
        <member name="P:Mozart.Collections.CollectionBase`1.Count">
            <summary>
            Must be overridden to provide the number of items in the collection.
            </summary>
            <value>The number of items in the collection.</value>
        </member>
        <member name="P:Mozart.Collections.CollectionBase`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Indicates whether the collection is read-only. Always returns false.
            </summary>
            <value>Always returns false.</value>
        </member>
        <member name="M:Mozart.Collections.CollectionBase`1.ToArray">
            <summary>
            Creates an array of the correct size, and copies all the items in the 
            collection into the array, by calling CopyTo.
            </summary>
            <returns>An array containing all the elements in the collection, in order.</returns>
        </member>
        <member name="M:Mozart.Collections.CollectionBase`1.GetEnumerator">
            <summary>
            Must be overridden to enumerate all the members of the collection.
            </summary>
            <returns>A generic IEnumerator&lt;T&gt; that can be used
            to enumerate all the items in the collection.</returns>
        </member>
        <member name="M:Mozart.Collections.CollectionBase`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies all the items in the collection into an array. Implemented by
            using the enumerator returned from GetEnumerator to get all the items
            and copy them to the provided array.
            </summary>
            <param name="array">Array to copy to.</param>
            <param name="index">Starting index in <paramref name="array"/> to copy to.</param>
        </member>
        <member name="P:Mozart.Collections.CollectionBase`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Indicates whether the collection is synchronized.
            </summary>
            <value>Always returns false, indicating that the collection is not synchronized.</value>
        </member>
        <member name="P:Mozart.Collections.CollectionBase`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Indicates the synchronization object for this collection.
            </summary>
            <value>Always returns this.</value>
        </member>
        <member name="M:Mozart.Collections.CollectionBase`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Provides an IEnumerator that can be used to iterate all the members of the
            collection. This implementation uses the IEnumerator&lt;T&gt; that was overridden
            by the derived classes to enumerate the members of the collection.
            </summary>
            <returns>An IEnumerator that can be used to iterate the collection.</returns>
        </member>
        <member name="M:Mozart.Collections.GenericTypeCache`1.#ctor(System.Type)">
            <summary>
            Constructs a cache for the specified generic type
            </summary>
            <param name="genericType">The generic type to close</param>
        </member>
        <member name="M:Mozart.Collections.GenericTypeCache`1.#ctor(System.Type,System.Func{System.Type,`0})">
            <summary>
            Constructs a cache for the specified generic type.
            </summary>
            <param name="genericType">The generic type to close</param>
            <param name="missingValueProvider">The implementation provider, which must close the generic type with the passed type</param>
        </member>
        <member name="T:Mozart.Collections.ICache`2">
            <summary>
            A cache implementation that extends the capability of most dictionary style classes to
            have a more complete set of methods commonly used in a dictionary scenario.
            </summary>
            <typeparam name="TKey">The key type of the cache</typeparam>
            <typeparam name="TValue">The value type of the cache</typeparam>
        </member>
        <member name="P:Mozart.Collections.ICache`2.MissingValueProvider">
            <summary>
            Sets the missing value provider used by the cache to create requested values that do not exist in the cache
            </summary>
        </member>
        <member name="P:Mozart.Collections.ICache`2.ValueAddedCallback">
            <summary>
            Sets the callback that is called when a new value is added to the cache
            </summary>
        </member>
        <member name="P:Mozart.Collections.ICache`2.ValueRemovedCallback">
            <summary>
            Sets the callback that is called when a value is removed or replaced from the cache
            </summary>
        </member>
        <member name="P:Mozart.Collections.ICache`2.DuplicateValueAdded">
            <summary>
            Sets the callback that is called when a duplicate value is added to the cache
            </summary>
        </member>
        <member name="P:Mozart.Collections.ICache`2.KeySelector">
            <summary>
            Specifies a selector that returns the key from a value which is used when a value is added to the cache
            </summary>
        </member>
        <member name="P:Mozart.Collections.ICache`2.Item(`0)">
            <summary>
            References a value in the cache, returning a newly created or existing value for the specified key, and
            adding a new or replacing an existing value in the cache
            </summary>
            <param name="key">The key references the value</param>
            <returns>The value from the cache</returns>
        </member>
        <member name="M:Mozart.Collections.ICache`2.Get(`0)">
            <summary>
            Get the value for the specified key
            </summary>
            <param name="key">The key referencing the value in the cache</param>
            <returns>The matching value if the key exists in the cache, otherwise an exception is thrown</returns>
        </member>
        <member name="M:Mozart.Collections.ICache`2.Get(`0,System.Func{`0,`1})">
            <summary>
            Get the value for the specified key, overriding the default missing value provider
            </summary>
            <param name="key">The key referencing the value in the cache</param>
            <param name="missingValueProvider">An overloaded missing value provider to create the value if it is not found in the cache</param>
            <returns>The matching value if the key exists in the cache, otherwise an exception is thrown</returns>
        </member>
        <member name="M:Mozart.Collections.ICache`2.Add(`0,`1)">
            <summary>
            Adds a value to the cache using the specified key. If the key already exists in the cache, an exception is thrown.
            </summary>
            <param name="key">The key referencing the value</param>
            <param name="value">The value</param>
        </member>
        <member name="M:Mozart.Collections.ICache`2.AddValue(`1)">
            <summary>
            Adds a value to the cache using the KeySelector to extract the key from the value. If the key already exists
            in the cache, an exception is thrown.
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="M:Mozart.Collections.ICache`2.Remove(`0)">
            <summary>
            Remove an existing value from the cache
            </summary>
            <param name="key">The key referencing the value</param>
        </member>
        <member name="M:Mozart.Collections.ICache`2.RemoveValue(`1)">
            <summary>
            Remove an existing value from the cache, using the KeySelector to extract the key to find the value
            </summary>
            <param name="value">The value to remove</param>
        </member>
        <member name="M:Mozart.Collections.ICache`2.Clear">
            <summary>
            Removes all items from the cache
            </summary>
        </member>
        <member name="M:Mozart.Collections.ICache`2.AddValues(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Fills the cache from a list of values, using the KeySelector to extract the key for each value.
            </summary>
            <param name="values"></param>
        </member>
        <member name="M:Mozart.Collections.ICache`2.WithValue(`0,System.Action{`1})">
            <summary>
            Calls the callback with the value matching the specified key
            </summary>
            <param name="key">The key referencing the value</param>
            <param name="callback">The callback to call</param>
            <returns>True if the value exists and the callback was called</returns>
        </member>
        <member name="M:Mozart.Collections.ICache`2.WithValue``1(`0,System.Func{`1,``0},``0)">
            <summary>
            Calls the function with the value matching the specified key, returning the result of that function
            </summary>
            <typeparam name="TResult">The result type of the function</typeparam>
            <param name="key">The key references the value</param>
            <param name="callback">The function to call</param>
            <param name="defaultValue">The default return value if the item does not exist in the cache</param>
            <returns>The return value of the function, or the defaultValue specified if the item does not exist in the cache</returns>
        </member>
        <member name="P:Mozart.Collections.ICache`2.Count">
            <summary>
            The number of items in the cache
            </summary>
        </member>
        <member name="M:Mozart.Collections.ICache`2.ContainsKey(`0)">
            <summary>
            Checks if the key exists in the cache
            </summary>
            <param name="key">The key to check</param>
            <returns>True if the key exists, otherwise false</returns>
        </member>
        <member name="M:Mozart.Collections.ICache`2.ContainsValue(`1)">
            <summary>
            Checks if a value exists in the cache
            </summary>
            <param name="value">The value to check</param>
            <returns>True if the value exists, otherwise false</returns>
        </member>
        <member name="M:Mozart.Collections.ICache`2.ForEach(System.Action{`1})">
            <summary>
            Calls the specified callback with each value in the cache
            </summary>
            <param name="callback">A callback that accepts the value for each item in the cache</param>
        </member>
        <member name="M:Mozart.Collections.ICache`2.ForEach(System.Action{`0,`1})">
            <summary>
            Calls the specified callback with each item in the cache
            </summary>
            <param name="callback">A callback that accepts the key and value for each item in the cache</param>
        </member>
        <member name="M:Mozart.Collections.ICache`2.Exists(System.Predicate{`1})">
            <summary>
            Uses a predicate to scan the cache for a matching value
            </summary>
            <param name="predicate">The predicate to run against each value</param>
            <returns>True if a matching value exists, otherwise false</returns>
        </member>
        <member name="M:Mozart.Collections.ICache`2.Find(System.Predicate{`1},`1@)">
            <summary>
            Uses a predicate to scan the cache for a matching value
            </summary>
            <param name="predicate">The predicate to run against each value</param>
            <param name="result">The matching value</param>
            <returns>True if a matching value was found, otherwise false</returns>
        </member>
        <member name="P:Mozart.Collections.ICache`2.Keys">
            <summary>
            Gets all keys that are stored in the cache
            </summary>
            <returns>An icollection of every key in the cache</returns>
        </member>
        <member name="P:Mozart.Collections.ICache`2.Values">
            <summary>
            Gets all values that are stored in the cache
            </summary>
            <returns>An icollection of every value in the cache</returns>
        </member>
        <member name="T:Mozart.Collections.ReadOnlyListBase`1">
            <summary>
            ReadOnlyListBase is an abstract class that can be used as a base class for a read-only collection that needs 
            to implement the generic IList&lt;T&gt; and non-generic IList collections. The derived class needs
            to override the Count property and the get part of the indexer. The implementation
            of all the other methods in IList&lt;T&gt; and IList are handled by ListBase.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyListBase`1.System#Collections#IList#Add(System.Object)">
            <summary>
            Adds an item to the end of the list. This implementation throws a NotSupportedException
            indicating that the list is read-only.
            </summary>
            <param name="value">The item to add to the list.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyListBase`1.System#Collections#IList#Clear">
            <summary>
            Removes all the items from the list, resulting in an empty list. This implementation throws a NotSupportedException
            indicating that the list is read-only.
            </summary>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyListBase`1.System#Collections#IList#Contains(System.Object)">
            <summary>
            Determines if the list contains any item that compares equal to <paramref name="value"/>.
            </summary>
            <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
            <param name="value">The item to search for.</param>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyListBase`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>
            Find the first occurrence of an item equal to <paramref name="value"/>
            in the list, and returns the index of that item.
            </summary>
            <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
            <param name="value">The item to search for.</param>
            <returns>The index of <paramref name="value"/>, or -1 if no item in the 
            list compares equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyListBase`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
            Insert a new item at the given index. This implementation throws a NotSupportedException
            indicating that the list is read-only.
            </summary>
            <param name="index">The index in the list to insert the item at. After the
            insertion, the inserted item is located at this index. The
            first item in the list has index 0.</param>
            <param name="value">The item to insert at the given index.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="P:Mozart.Collections.ReadOnlyListBase`1.System#Collections#IList#IsFixedSize">
            <summary>
            Returns whether the list is a fixed size. This implementation always returns true.
            </summary>
            <value>Alway true, indicating that the list is fixed size.</value>
        </member>
        <member name="P:Mozart.Collections.ReadOnlyListBase`1.System#Collections#IList#IsReadOnly">
            <summary>
            Returns whether the list is read only. This implementation always returns true.
            </summary>
            <value>Alway true, indicating that the list is read-only.</value>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyListBase`1.System#Collections#IList#Remove(System.Object)">
            <summary>
            Searches the list for the first item that compares equal to <paramref name="value"/>.
            If one is found, it is removed. Otherwise, the list is unchanged.  This implementation throws a NotSupportedException
            indicating that the list is read-only.
            </summary>
            <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
            <param name="value">The item to remove from the list.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyListBase`1.System#Collections#IList#RemoveAt(System.Int32)">
            <summary>
            Removes the item at the given index. This implementation throws a NotSupportedException
            indicating that the list is read-only.
            </summary>
            <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="P:Mozart.Collections.ReadOnlyListBase`1.System#Collections#IList#Item(System.Int32)">
            <summary>
            Gets or sets the value at a particular index in the list.
            </summary>
            <param name="index">The index in the list to get or set an item at. The
            first item in the list has index 0, and the last has index Count-1.</param>
            <value>The item at the given index.</value>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> cannot be converted to T.</exception>
            <exception cref="T:System.NotSupportedException">Always thrown from the setter, indicating that the list
            is read-only.</exception>
        </member>
        <member name="P:Mozart.Collections.ReadOnlyListBase`1.Count">
            <summary>
            The property must be overridden by the derived class to return the number of 
            items in the list.
            </summary>
            <value>The number of items in the list.</value>
        </member>
        <member name="P:Mozart.Collections.ReadOnlyListBase`1.Item(System.Int32)">
            <summary>
            The get part of the indexer must be overridden by the derived class to get 
            values of the list at a particular index.
            </summary>
            <param name="index">The index in the list to get or set an item at. The
            first item in the list has index 0, and the last has index Count-1.</param>
            <returns>The item at the given index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count.</exception>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyListBase`1.GetEnumerator">
            <summary>
            Enumerates all of the items in the list, in order. The item at index 0
            is enumerated first, then the item at index 1, and so on.
            </summary>
            <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the list.</returns>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyListBase`1.Contains(`0)">
            <summary>
            Determines if the list contains any item that compares equal to <paramref name="item"/>.
            The implementation simply checks whether IndexOf(item) returns a non-negative value.
            </summary>
            <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
            <param name="item">The item to search for.</param>
            <returns>True if the list contains an item that compares equal to <paramref name="item"/>.</returns>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyListBase`1.IndexOf(`0)">
            <summary>
            Finds the index of the first item in the list that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search fror.</param>
            <returns>The index of the first item in the list that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyListBase`1.System#Collections#Generic#IList{T}#Insert(System.Int32,`0)">
            <summary>
            Inserts a new item at the given index. This implementation throws a NotSupportedException
            indicating that the list is read-only.
            </summary>
            <param name="index">The index in the list to insert the item at. After the
            insertion, the inserted item is located at this index. The
            first item in the list has index 0.</param>
            <param name="item">The item to insert at the given index.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyListBase`1.System#Collections#Generic#IList{T}#RemoveAt(System.Int32)">
            <summary>
            Removes the item at the given index.  This implementation throws a NotSupportedException
            indicating that the list is read-only.
            </summary>
            <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyListBase`1.CopyTo(`0[])">
            <summary>
            Copies all the items in the list, in order, to <paramref name="array"/>,
            starting at index 0.
            </summary>
            <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count.</param>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyListBase`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
            <summary>
            Copies a range of elements from the list to <paramref name="array"/>,
            starting at <paramref name="arrayIndex"/>.
            </summary>
            <param name="index">The starting index in the source list of the range to copy.</param>
            <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count + arrayIndex.</param>
            <param name="arrayIndex">The starting index in <paramref name="array"/>
            to copy to.</param>
            <param name="count">The number of items to copy.</param>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyListBase`1.IndexOf(`0,System.Int32)">
            <summary>
            Finds the index of the first item, in the range of items extending from <paramref name="index"/> to the end,  
            that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search fror.</param>
            <param name="index">The starting index of the range to check.</param>
            <returns>The index of the first item in the given range that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyListBase`1.IndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Finds the index of the first item, in the range of <paramref name="count"/> items starting from <paramref name="index"/>,  
            that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search fror.</param>
            <param name="index">The starting index of the range to check.</param>
            <param name="count">The number of items in range to check.</param>
            <returns>The index of the first item in the given range that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyListBase`1.Range(System.Int32,System.Int32)">
            <summary>
            Returns a view onto a sub-range of this list. Items are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. 
            </summary>
            <remarks>
            <para>This method can be used to apply an algorithm to a portion of a list. For example:</para>
            <code>Algorithms.Reverse(deque.Range(3, 6))</code>
            will return the reverse opf the 6 items beginning at index 3.</remarks>
            <param name="start">The starting index of the view.</param>
            <param name="count">The number of items in the view.</param>
            <returns>A list that is a view onto the given sub-part of this list. </returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> or <paramref name="count"/> is negative.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> + <paramref name="count"/> is greater than the
            size of the list.</exception>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyListBase`1.CannotModifyCollection">
            <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
        </member>
        <member name="M:Mozart.Collections.Implements.IndexOf``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Finds the index of the first item in a list equal to a given item. A passed
            IEqualityComparer is used to determine equality.
            </summary>
            <param name="list">The list to search.</param>
            <param name="item">The item to search for.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
            <returns>The index of the first item equal to <paramref name="item"/>. -1 if no such item exists in the list.</returns>
        </member>
        <member name="T:Mozart.Collections.ListBase`1">
            <summary>
            ListBase is an abstract class that can be used as a base class for a read-write collection that needs 
            to implement the generic IList&lt;T&gt; and non-generic IList collections. The derived class needs
            to override the following methods: Count, Clear, Insert, RemoveAt, and the indexer. The implementation
            of all the other methods in IList&lt;T&gt; and IList are handled by ListBase.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.System#Collections#IList#Add(System.Object)">
            <summary>
            Adds an item to the end of the list. This method is equivalent to calling: 
            <code>Insert(Count, item)</code>
            </summary>
            <param name="value">The item to add to the list.</param>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> cannot be converted to T.</exception>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.System#Collections#IList#Clear">
            <summary>
            Removes all the items from the list, resulting in an empty list.
            </summary>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.System#Collections#IList#Contains(System.Object)">
            <summary>
            Determines if the list contains any item that compares equal to <paramref name="value"/>.
            </summary>
            <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
            <param name="value">The item to search for.</param>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>
            Find the first occurrence of an item equal to <paramref name="value"/>
            in the list, and returns the index of that item.
            </summary>
            <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
            <param name="value">The item to search for.</param>
            <returns>The index of <paramref name="value"/>, or -1 if no item in the 
            list compares equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
            Insert a new
            item at the given index. 
            </summary>
            <param name="index">The index in the list to insert the item at. After the
            insertion, the inserted item is located at this index. The
            first item in the list has index 0.</param>
            <param name="value">The item to insert at the given index.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than Count.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> cannot be converted to T.</exception>
        </member>
        <member name="P:Mozart.Collections.ListBase`1.System#Collections#IList#IsFixedSize">
            <summary>
            Returns whether the list is a fixed size. This implementation always returns false.
            </summary>
            <value>Alway false, indicating that the list is not fixed size.</value>
        </member>
        <member name="P:Mozart.Collections.ListBase`1.System#Collections#IList#IsReadOnly">
            <summary>
            Returns whether the list is read only. This implementation returns the value
            from ICollection&lt;T&gt;.IsReadOnly, which is by default, false.
            </summary>
            <value>By default, false, indicating that the list is not read only.</value>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.System#Collections#IList#Remove(System.Object)">
            <summary>
            Searches the list for the first item that compares equal to <paramref name="value"/>.
            If one is found, it is removed. Otherwise, the list is unchanged.
            </summary>
            <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
            <param name="value">The item to remove from the list.</param>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> cannot be converted to T.</exception>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.System#Collections#IList#RemoveAt(System.Int32)">
            <summary>
            Removes the
            item at the given index. 
            </summary>
            <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count.</exception>
        </member>
        <member name="P:Mozart.Collections.ListBase`1.System#Collections#IList#Item(System.Int32)">
            <summary>
            Gets or sets the
            value at a particular index in the list.
            </summary>
            <param name="index">The index in the list to get or set an item at. The
            first item in the list has index 0, and the last has index Count-1.</param>
            <value>The item at the given index.</value>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> cannot be converted to T.</exception>
        </member>
        <member name="P:Mozart.Collections.ListBase`1.Count">
            <summary>
            The property must be overridden by the derived class to return the number of 
            items in the list.
            </summary>
            <value>The number of items in the list.</value>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.Clear">
            <summary>
            This method must be overridden by the derived class to empty the list
            of all items.
            </summary>
        </member>
        <member name="P:Mozart.Collections.ListBase`1.Item(System.Int32)">
            <summary>
            The indexer must be overridden by the derived class to get and set
            values of the list at a particular index.
            </summary>
            <param name="index">The index in the list to get or set an item at. The
            first item in the list has index 0, and the last has index Count-1.</param>
            <returns>The item at the given index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count.</exception>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.Insert(System.Int32,`0)">
            <summary>
            This method must be overridden by the derived class to insert a new
            item at the given index. 
            </summary>
            <param name="index">The index in the list to insert the item at. After the
            insertion, the inserted item is located at this index. The
            first item in the list has index 0.</param>
            <param name="item">The item to insert at the given index.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than Count.</exception>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.RemoveAt(System.Int32)">
            <summary>
            This method must be overridden by the derived class to remove the
            item at the given index. 
            </summary>
            <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count.</exception>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.GetEnumerator">
            <summary>
            Enumerates all of the items in the list, in order. The item at index 0
            is enumerated first, then the item at index 1, and so on.
            </summary>
            <remarks>The enumerator does not check for changes made
            to the structure of the list. Thus, changes to the list during
            enumeration may cause incorrect enumeration or out of range
            exceptions. Consider overriding this method and adding checks
            for structural changes.</remarks>
            <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the list.</returns>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.Contains(`0)">
            <summary>
            Determines if the list contains any item that compares equal to <paramref name="item"/>.
            The implementation simply checks whether IndexOf(item) returns a non-negative value.
            </summary>
            <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
            <param name="item">The item to search for.</param>
            <returns>True if the list contains an item that compares equal to <paramref name="item"/>.</returns>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.Add(`0)">
            <summary>
            Adds an item to the end of the list. This method is equivalent to calling: 
            <code>Insert(Count, item)</code>
            </summary>
            <param name="item">The item to add to the list.</param>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.Remove(`0)">
            <summary>
            Searches the list for the first item that compares equal to <paramref name="item"/>.
            If one is found, it is removed. Otherwise, the list is unchanged.
            </summary>
            <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
            <param name="item">The item to remove from the list.</param>
            <returns>True if an item was found and removed that compared equal to
            <paramref name="item"/>. False if no such item was in the list.</returns>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.IndexOf(`0)">
            <summary>
            Finds the index of the first item in the list that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search fror.</param>
            <returns>The index of the first item in the list that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.CopyTo(`0[])">
            <summary>
            Copies all the items in the list, in order, to <paramref name="array"/>,
            starting at index 0.
            </summary>
            <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count.</param>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
            <summary>
            Copies a range of elements from the list to <paramref name="array"/>,
            starting at <paramref name="arrayIndex"/>.
            </summary>
            <param name="index">The starting index in the source list of the range to copy.</param>
            <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count + arrayIndex.</param>
            <param name="arrayIndex">The starting index in <paramref name="array"/>
            to copy to.</param>
            <param name="count">The number of items to copy.</param>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.IndexOf(`0,System.Int32)">
            <summary>
            Finds the index of the first item, in the range of items extending from <paramref name="index"/> to the end,  
            that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search fror.</param>
            <param name="index">The starting index of the range to check.</param>
            <returns>The index of the first item in the given range that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.IndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Finds the index of the first item, in the range of <paramref name="count"/> items starting from <paramref name="index"/>,  
            that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search fror.</param>
            <param name="index">The starting index of the range to check.</param>
            <param name="count">The number of items in range to check.</param>
            <returns>The index of the first item in the given range that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.LastIndexOf(`0)">
            <summary>
            Finds the index of the last item in the list that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search fror.</param>
            <returns>The index of the last item in the list that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.LastIndexOf(`0,System.Int32)">
            <summary>
            Finds the index of the last item, in the range of items extending from the beginning
            of the list to <paramref name="index"/>, that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search fror.</param>
            <param name="index">The ending index of the range to check.</param>
            <returns>The index of the last item in the given range that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.LastIndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Finds the index of the last item, in the range of <paramref name="count"/> items ending at <paramref name="index"/>, 
            that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search for.</param>
            <param name="index">The ending index of the range to check.</param>
            <param name="count">The number of items in range to check.</param>
            <returns>The index of the last item in the given range that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.Range(System.Int32,System.Int32)">
            <summary>
            Returns a view onto a sub-range of this list. Items are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to this list
            are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the 
            view, but insertions and deletions in the underlying list do not.
            </summary>
            <remarks>
            <para>This method can be used to apply an algorithm to a portion of a list. For example:</para>
            <code>Algorithms.ReverseInPlace(deque.Range(3, 6))</code>
            will reverse the 6 items beginning at index 3.</remarks>
            <param name="start">The starting index of the view.</param>
            <param name="count">The number of items in the view.</param>
            <returns>A list that is a view onto the given sub-part of this list. </returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> or <paramref name="count"/> is negative.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> + <paramref name="count"/> is greater than the
            size of the list.</exception>
        </member>
        <member name="M:Mozart.Collections.ListBase`1.ConvertToItemType(System.String,System.Object)">
            <summary>
            Convert the given parameter to T. Throw an ArgumentException
            if it isn't.
            </summary>
            <param name="name">parameter name</param>
            <param name="value">parameter value</param>
        </member>
        <member name="T:Mozart.Collections.MultiDictionary`2">
            <summary>
            The MultiDictionary class that associates values with a key.
            </summary>
            <typeparam name="TKey">The type of the keys.</typeparam>
            <typeparam name="TValue">The of values associated with the keys.</typeparam>
            <remarks>
            Unlike an Dictionary, each key can have multiple values associated with it.
            When indexing an MultiDictionary, instead of a single value associated with a key, you retrieve an enumeration of values.
            When constructed, you can chose to allow the same value to be associated with a key multiple times, or only one time.
            </remarks>
        </member>
        <member name="F:Mozart.Collections.MultiDictionary`2.changeStamp">
            <summary>
            An integer that is changed every time the table structurally changes.
            </summary>
        </member>
        <member name="F:Mozart.Collections.MultiDictionary`2.allowDuplicateValues">
            <summary>
            The comparer for comparing keys
            </summary>
        </member>
        <member name="F:Mozart.Collections.MultiDictionary`2.valueEqualityComparer">
            <summary>
            The comparer for comparing values;
            </summary>
        </member>
        <member name="F:Mozart.Collections.MultiDictionary`2.dictonary">
            <summary>
            The hash that holds the keys and values.
            </summary> 
        </member>
        <member name="F:Mozart.Collections.MultiDictionary`2.newCollectionFactory">
            <summary>
            The function to construct a new <see cref="T:System.Collections.Generic.ICollection`1"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.#ctor">
            <summary>
            Whether duplicate values for the same key are allowed.
            </summary>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.#ctor(System.Boolean)">
            <summary>
            Create a new MultiDictionary.
            The default ordering of keys and values are used. 
            If duplicate values are allowed, multiple copies of the same value can be associated with the same key.
            </summary>
            <remarks>The default ordering of keys and values will be used, as defined by TKey and TValue's implementation
            of IComparable&lt;T&gt; (or IComparable if IComparable&lt;T&gt; is not implemented). If a different ordering should be
            used, other constructors allow a custom Comparer or IComparer to be passed to changed the ordering.
            [EX]the key "foo" could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            An exception condition occured by TKey or TValue does not implement either IComparable&lt;T&gt; or IComparable.
            </remarks>
            <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a new MultiDictionary.
            If duplicate values are allowed, multiple copies of the same value can be associated with the same key.
            </summary>
            <param name="allowDuplicateValues">Can the same value be associated with a key multiple times</param>
            <param name="keyEqualityComparer">An IEqualityComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
            <remarks>
            [EX]the key "foo" could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            Exception condition occured by TValue does not implement either IComparable&lt;TValue&gt; or IComparable.
            </remarks>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Create a new MultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key.
            </summary>
            <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
            <param name="keyEqualityComparer">An IEqualityComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
            <param name="valueEqualityComparer">An IEqualityComparer&lt;TValue&gt; instance that will be used to compare values.</param>
            <remarks>
            [EX]the key "foo" could have "a", "a", and "b" associated with it.
            If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </remarks>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1},System.Collections.Generic.Dictionary{`0,Mozart.Collections.InnerCollectionView{`1}})">
            <summary>
            Create a new MultiDictionary. Private constructor, for use by Clone().
            </summary>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.Add(`0,`1)">
            <summary>
            <para>Adds a new value to be associated with a key. If duplicate values are permitted, this
            method always adds a new key-value pair to the dictionary.</para>
            <para>If duplicate values are not permitted, and <paramref name="key"/> already has a value
            equal to <paramref name="value"/> associated with it, then that value is replaced with <paramref name="value"/>,
            and the number of values associate with <paramref name="key"/> is unchanged.</para>
            </summary>
            <param name="key">The key to associate with.</param>
            <param name="value">The value to associated with <paramref name="key"/>.</param>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.Remove(`0,`1)">
            <summary>
            Removes a given value from the values associated with a key. If the
            last value is removed from a key, the key is removed also.
            </summary>
            <param name="key">A key to remove a value from.</param>
            <param name="value">The value to remove.</param>
            <returns>
            True if <paramref name="value"/> was associated with <paramref name="key"/> (and was
            therefore removed). False if <paramref name="value"/> was not associated with <paramref name="key"/>.
            </returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.Remove(`0)">
            <summary>
            Removes a key and all associated values from the dictionary. If the
            key is not present in the dictionary, it is unchanged and false is returned.
            </summary>
            <param name="key">The key to remove.</param>
            <returns>True if the key was present and was removed. Returns 
            false if the key was not present.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.Clear">
            <summary>
            Removes all keys and values from the dictionary.
            </summary>
        </member>
        <member name="P:Mozart.Collections.MultiDictionary`2.KeyComparer">
            <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare keys in this dictionary. 
            </summary>
            <value>If the dictionary was created using a comparer, that comparer is returned. Otherwise
            the default comparer for TKey (EqualityComparer&lt;TKey&gt;.Default) is returned.</value>
        </member>
        <member name="P:Mozart.Collections.MultiDictionary`2.ValueComparer">
            <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare values in this dictionary. 
            </summary>
            <value>If the dictionary was created using a comparer, that comparer is returned. Otherwise
            the default comparer for TValue (EqualityComparer&lt;TValue&gt;.Default) is returned.</value>
        </member>
        <member name="P:Mozart.Collections.MultiDictionary`2.Count">
            <summary>
            Gets the number of key-value pairs in the dictionary. Each value associated
            with a given key is counted. If duplicate values are permitted, each duplicate
            value is included in the count.
            </summary>
            <value>The number of key-value pairs in the dictionary.</value>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.Contains(`0,`1)">
            <summary>
            Checks to see if <paramref name="value"/> is associated with <paramref name="key"/>
            in the dictionary.
            </summary>
            <param name="key">The key to check.</param>
            <param name="value">The value to check.</param>
            <returns>True if <paramref name="value"/> is associated with <paramref name="key"/>.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.ContainsKey(`0)">
            <summary>
            Checks to see if the key is present in the dictionary and has
            at least one value associated with it.
            </summary>
            <param name="key">The key to check.</param>
            <returns>True if <paramref name="key"/> is present and has at least
            one value associated with it. Returns false otherwise.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.EqualValues(`1,`1)">
            <summary>
            Determine if two values are equal.
            </summary>
            <param name="value1">First value to compare.</param>
            <param name="value2">Second value to compare.</param>
            <returns>True if the values are equal.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.EnumerateKeys">
            <summary>
            Enumerate all the keys in the dictionary. 
            </summary>
            <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the dictionary that
            have at least one value associated with them.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.TryEnumerateValues(`0,System.Collections.Generic.IEnumerator{`1}@)">
            <summary>
            Determines if this dictionary contains a key equal to <paramref name="key"/>. If so, all the values
            associated with that key are returned through the values parameter. 
            </summary>
            <param name="key">The key to search for.</param>
            <param name="values">Returns all values associated with key, if true was returned.</param>
            <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.CountValues(`0)">
            <summary>
            Gets the number of values associated with a given key.
            </summary>
            <param name="key">The key to count values of.</param>
            <returns>The number of values associated with <paramref name="key"/>. If <paramref name="key"/>
            is not present in the dictionary, zero is returned.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.EnumerateValues(Mozart.Collections.InnerCollectionView{`1})">
            <summary>
             Enumerate the values in the a KeyAndValues structure.
            </summary>
            <param name="keyAndValues">Item with the values to enumerate.</param>
            <remarks>
            Can't return the array directly because:
            1. The array might be larger than the count.
            2. We can't allow clients to down-cast to the array and modify it.
            3. We have to abort enumeration if the hash changes.
            </remarks>
            <returns>An enumerable that enumerates the items in the KeyAndValues structure.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.CheckEnumerationStamp(System.Int32)">
            <summary>
            Checks the given stamp against the current change stamp.
            </summary>
            <remarks>
            If different with given stamp and change stamp value,
            then the collection has changed during enumeration and an InvalidOperationException must be thrown
            </remarks>
            <param name="startStamp">changeStamp at the start of the enumeration.</param>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.System#ICloneable#Clone">
            <summary>
            Implements ICloneable.Clone. Makes a shallow clone of this dictionary;
            </summary>
            <remarks>
            if keys or values are reference types, then they are not cloned.
            </remarks>
            <returns>The cloned dictionary.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.Clone">
            <summary>
            Makes a shallow clone of this dictionary
            </summary>
            <remarks>
            if keys or values of the dictionary are reference types, then they are not cloned.
            If TKey or TValue is a value type, then each element is copied as if by simple assignment.
            Cloning the dictionary takes time O(N), where N is the number of key-value pairs in the dictionary.
            </remarks>
            <returns>The cloned dictionary.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionary`2.CloneContents">
            <summary>
            Makes a deep clone of this dictionary. A new dictionary is created with a clone of
            each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is
            a value type, then each element is copied as if by simple assignment.
            </summary>
            <remarks>
            If TKey or TValue is a reference type, it must implement ICloneable. Otherwise, an InvalidOperationException is thrown.
            An exception occured by TKey or TValue is a reference type that does not implement ICloneable.
            <para>Cloning the dictionary takes time O(N log N), where N is the number of key-value pairs in the dictionary.</para></remarks>
            <returns>The cloned dictionary.</returns>
        </member>
        <member name="T:Mozart.Collections.MultiDictionaryBase`2">
            <summary>
            MultiDictionaryBase is a base class that can be used to more easily implement a class
            that associates multiple values to a single key. The class implements the generic
            IDictionary&lt;TKey, ICollection&lt;TValue&gt;&gt; interface.
            </summary>
            <remarks>
            <para>To use MultiDictionaryBase as a base class, the derived class must override
            Count, Clear, Add, Remove(TKey), Remove(TKey,TValue), Contains(TKey,TValue), 
            EnumerateKeys, and TryEnumerateValuesForKey. </para>
            <para>It may wish consider overriding CountValues, CountAllValues, ContainsKey,
            and EqualValues, but these are not required.
            </para>
            </remarks>
            <typeparam name="TKey">The key type of the dictionary.</typeparam>
            <typeparam name="TValue">The value type of the dictionary.</typeparam>
        </member>
        <member name="P:Mozart.Collections.MultiDictionaryBase`2.Values">
            <summary>
            Gets a read-only collection of all the values in the dictionary. 
            </summary>
            <returns>A read-only ICollection&lt;TValue&gt; of all the values in the dictionary.</returns>
        </member>
        <member name="P:Mozart.Collections.MultiDictionaryBase`2.Item(`0)">
            <summary>
            Returns a collection of all of the values in the dictionary associated with <paramref name="key"/>,
            or changes the set of values associated with <paramref name="key"/>.
            If the key is not present in the dictionary, an ICollection enumerating no
            values is returned. The returned collection of values is read-write, and can be used to 
            modify the collection of values associated with the key.
            </summary>
            <param name="key">The key to get the values associated with.</param>
            <value>An ICollection&lt;TValue&gt; with all the values associated with <paramref name="key"/>.</value>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.Clear">
            <summary>
            Clears the dictionary. This method must be overridden in the derived class.
            </summary>
        </member>
        <member name="P:Mozart.Collections.MultiDictionaryBase`2.Count">
            <summary>
            Gets the number of keys in the dictionary. This property must be overridden
            in the derived class.
            </summary>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.Add(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
            <summary>
            Adds a key-value pair to the collection. The value part of the pair must be a collection
            of values to associate with the key. If values are already associated with the given
            key, the new values are added to the ones associated with that key.
            </summary>
            <param name="item">A KeyValuePair contains the Key and Value collection to add.</param>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.System#Collections#Generic#IDictionary{TKey,System#Collections#Generic#ICollection{TValue}}#Add(`0,System.Collections.Generic.ICollection{`1})">
            <summary>
            Implements IDictionary&lt;TKey, IEnumerable&lt;TValue&gt;&gt;.Add. If the 
            key is already present, and ArgumentException is thrown. Otherwise, a
            new key is added, and new values are associated with that key.
            </summary>
            <param name="key">Key to add.</param>
            <param name="values">Values to associate with that key.</param>
            <exception cref="T:System.ArgumentException">The key is already present in the dictionary.</exception>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.Remove(`0)">
            <summary>
            Removes a key from the dictionary. This method must be overridden in the derived class.
            </summary>
            <param name="key">Key to remove from the dictionary.</param>
            <returns>True if the key was found, false otherwise.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.Remove(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
            <summary>
            Removes a set of values from a given key. If all values associated with a key are
            removed, then the key is removed also.
            </summary>
            <param name="pair">A KeyValuePair contains a key and a set of values to remove from that key.</param>
            <returns>True if at least one values was found and removed.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.TryGetValue(`0,System.Collections.Generic.ICollection{`1}@)">
            <summary>
            Determines if this dictionary contains a key equal to <paramref name="key"/>. If so, all the values
            associated with that key are returned through the values parameter. This method must be
            overridden by the derived class.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="values">Returns all values associated with key, if true was returned.</param>
            <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.ContainsKey(`0)">
            <summary>
            Determines whether a given key is found in the dictionary.
            </summary>
            <remarks>The default implementation simply calls TryEnumerateValuesForKey.
            It may be appropriate to override this method to 
            provide a more efficient implementation.</remarks>
            <param name="key">Key to look for in the dictionary.</param>
            <returns>True if the key is present in the dictionary.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.Contains(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
            <summary>
            Determines if this dictionary contains the given key and all of the values associated with that key..
            </summary>
            <param name="pair">A key and collection of values to search for.</param>
            <returns>True if the dictionary has associated all of the values in <paramref name="pair"/>.Value with <paramref name="pair"/>.Key.</returns>
        </member>
        <member name="P:Mozart.Collections.MultiDictionaryBase`2.Keys">
            <summary>
            Gets a read-only collection all the keys in this dictionary.
            </summary>
            <value>An readonly ICollection&lt;TKey&gt; of all the keys in this dictionary.</value>
        </member>
        <member name="P:Mozart.Collections.MultiDictionaryBase`2.System#Collections#Generic#IDictionary{TKey,System#Collections#Generic#ICollection{TValue}}#Values">
            <summary>
            Gets a read-only collection of all the value collections in the dictionary. 
            </summary>
            <returns>A read-only ICollection&lt;IEnumerable&lt;TValue&gt;&gt; of all the values in the dictionary.</returns>
        </member>
        <member name="P:Mozart.Collections.MultiDictionaryBase`2.System#Collections#Generic#IDictionary{TKey,System#Collections#Generic#ICollection{TValue}}#Item(`0)">
            <summary>
            Gets a collection of all the values in the dictionary associated with <paramref name="key"/>,
            or changes the set of values associated with <paramref name="key"/>.
            If the key is not present in the dictionary, a KeyNotFound exception is thrown.
            </summary>
            <param name="key">The key to get the values associated with.</param>
            <value>An IEnumerable&lt;TValue&gt; that enumerates all the values associated with <paramref name="key"/>.</value>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The given key is not present in the dictionary.</exception>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.GetEnumerator">
            <summary>
            Enumerate all the keys in the dictionary, and for each key, the collection of values for that key.
            </summary>
            <returns>An enumerator to enumerate all the key, ICollection&lt;value&gt; pairs in the dictionary.</returns>
        </member>
        <member name="T:Mozart.Collections.MultiDictionaryBase`2.ValuesForKeyCollection">
            <summary>
            A private class that provides the ICollection&lt;TValue&gt; for a particular key. This is the collection
            that is returned from the indexer. The collections is read-write, live, and can be used to add, remove,
            etc. values from the multi-dictionary.
            </summary>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.ValuesForKeyCollection.#ctor(Mozart.Collections.MultiDictionaryBase{`0,`1},`0)">
            <summary>
            Constructor. Initializes this collection.
            </summary>
            <param name="myDictionary">Dictionary we're using.</param>
            <param name="key">The key we're looking at.</param>
        </member>
        <member name="P:Mozart.Collections.MultiDictionaryBase`2.ValuesForKeyCollection.Count">
            <summary>
            Get the number of values associated with the key.
            </summary>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.ValuesForKeyCollection.Clear">
            <summary>
            Remove the key and all values associated with it.
            </summary>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.ValuesForKeyCollection.Add(`1)">
            <summary>
            Add a new values to this key.
            </summary>
            <param name="item">New values to add.</param>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.ValuesForKeyCollection.Remove(`1)">
            <summary>
            Remove a value currently associated with key.
            </summary>
            <param name="item">Value to remove.</param>
            <returns>True if item was assocaited with key, false otherwise.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.ValuesForKeyCollection.GetEnumerator">
            <summary>
            Enumerate all the values associated with key.
            </summary>
            <returns>An IEnumerator&lt;TValue&gt; that enumerates all the values associated with key.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.ValuesForKeyCollection.Contains(`1)">
            <summary>
            Determines if the given values is associated with key.
            </summary>
            <param name="item">Value to check for.</param>
            <returns>True if value is associated with key, false otherwise.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.ValuesForKeyCollection.NoValues">
            <summary>
            A simple function that returns an IEnumerator&lt;TValue&gt; that
            doesn't yield any values. A helper.
            </summary>
            <returns>An IEnumerator&lt;TValue&gt; that yields no values.</returns>
        </member>
        <member name="T:Mozart.Collections.MultiDictionaryBase`2.KeysCollection">
            <summary>
            A private class that implements ICollection&lt;TKey&gt; and ICollection for the
            Keys collection. The collection is read-only.
            </summary>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.KeysCollection.#ctor(Mozart.Collections.MultiDictionaryBase{`0,`1})">
            <summary>
            Constructor.
            </summary>
            <param name="myDictionary">The dictionary this is associated with.</param>
        </member>
        <member name="T:Mozart.Collections.MultiDictionaryBase`2.ValuesCollection">
            <summary>
            A private class that implements ICollection&lt;TValue&gt; and ICollection for the
            Values collection. The collection is read-only.
            </summary>
        </member>
        <member name="T:Mozart.Collections.MultiDictionaryBase`2.EnumerableValuesCollection">
            <summary>
            A private class that implements ICollection&lt;ICollection&lt;TValue&gt;&gt; and ICollection for the
            Values collection on IDictionary. The collection is read-only.
            </summary>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.AddMany(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            <para>Adds new values to be associated with a key. If duplicate values are permitted, this
            method always adds new key-value pairs to the dictionary.</para>
            <para>If duplicate values are not permitted, and <paramref name="key"/> already has a value
            equal to one of <paramref name="values"/> associated with it, then that value is replaced,
            and the number of values associate with <paramref name="key"/> is unchanged.</para>
            </summary>
            <param name="key">The key to associate with.</param>
            <param name="values">A collection of values to associate with <paramref name="key"/>.</param>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.Add(`0,`1)">
            <summary>
            Adds a new key-value pair to the dictionary.  This method must be overridden in the derived class.
            </summary>
            <param name="key">Key to add.</param>
            <param name="value">Value to associated with the key.</param>
            <exception cref="T:System.ArgumentException">key is already present in the dictionary</exception>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.Remove(`0,`1)">
            <summary>
            Removes a key-value pair from the dictionary. This method must be overridden in the derived class.
            </summary>
            <param name="key">Key to remove from the dictionary.</param>
            <param name="value">Associated value to remove from the dictionary.</param>
            <returns>True if the key-value pair was found, false otherwise.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.RemoveMany(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Removes a collection of values from the values associated with a key. If the
            last value is removed from a key, the key is removed also.
            </summary>
            <param name="key">A key to remove values from.</param>
            <param name="values">A collection of values to remove.</param>
            <returns>The number of values that were present and removed. </returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all of the keys (and any associated values) in a collection
            of keys. If a key is not present in the dictionary, nothing happens.
            </summary>
            <param name="keyCollection">A collection of key values to remove.</param>
            <returns>The number of keys from the collection that were present and removed.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.Contains(`0,`1)">
            <summary>
            Determines if this dictionary contains a key-value pair equal to <paramref name="key"/> and 
            <paramref name="value"/>. The dictionary is not changed. This method must be overridden in the derived class.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="value">The value to search for.</param>
            <returns>True if the dictionary has associated <paramref name="value"/> with <paramref name="key"/>.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.Replace(`0,`1)">
            <summary>
            Replaces all values associated with <paramref name="key"/> with the single value <paramref name="value"/>.
            </summary>
            <remarks>This implementation simply calls Remove, followed by Add.</remarks>
            <param name="key">The key to associate with.</param>
            <param name="value">The new values to be associated with <paramref name="key"/>.</param>
            <returns>Returns true if some values were removed. Returns false if <paramref name="key"/> was not
            present in the dictionary before Replace was called.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.ReplaceMany(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Replaces all values associated with <paramref name="key"/> with a new collection
            of values. If the collection does not permit duplicate values, and <paramref name="values"/> has duplicate
            items, then only the last of duplicates is added.
            </summary>
            <param name="key">The key to associate with.</param>
            <param name="values">The new values to be associated with <paramref name="key"/>.</param>
            <returns>Returns true if some values were removed. Returns false if <paramref name="key"/> was not
            present in the dictionary before Replace was called.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.ToString">
            <summary>
            Shows the string representation of the dictionary. The string representation contains
            a list of the mappings in the dictionary.
            </summary>
            <returns>The string representation of the dictionary.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.EnumerateKeys">
            <summary>
            Enumerate all the keys in the dictionary. This method must be overridden by a derived
            class.
            </summary>
            <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the collection that
            have at least one value associated with them.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.TryEnumerateValues(`0,System.Collections.Generic.IEnumerator{`1}@)">
            <summary>
            Enumerate all of the values associated with a given key. This method must be overridden
            by the derived class. If the key exists and has values associated with it, an enumerator for those
            values is returned throught <paramref name="values"/>. If the key does not exist, false is returned.
            </summary>
            <param name="key">The key to get values for.</param>
            <param name="values">If true is returned, this parameter receives an enumerators that
            enumerates the values associated with that key.</param>
            <returns>True if the key exists and has values associated with it. False otherwise.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.EqualValues(`1,`1)">
            <summary>
            If the derived class does not use the default comparison for values, this
            methods should be overridden to compare two values for equality. This is
            used for the correct implementation of ICollection.Contains on the Values
            and KeyValuePairs collections.
            </summary>
            <param name="value1">First value to compare.</param>
            <param name="value2">Second value to compare.</param>
            <returns>True if the values are equal.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.CountValues(`0)">
            <summary>
            Gets a count of the number of values associated with a key. The
            default implementation is slow; it enumerators all of the values
            (using TryEnumerateValuesForKey) to count them. A derived class
            may be able to supply a more efficient implementation.
            </summary>
            <param name="key">The key to count values for.</param>
            <returns>The number of values associated with <paramref name="key"/>.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.CountAllValues">
            <summary>
            Gets a total count of values in the collection. This default implementation
            is slow; it enumerates all of the keys in the dictionary and calls CountValues on each.
            A derived class may be able to supply a more efficient implementation.
            </summary>
            <returns>The total number of values associated with all keys in the dictionary.</returns>
        </member>
        <member name="M:Mozart.Collections.MultiDictionaryBase`2.DebuggerDisplayString">
            <summary>
            Display the contents of the dictionary in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
            <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
        </member>
        <member name="T:Mozart.Collections.ReadOnlyCollectionBase`1">
            <summary>
            ReadOnlyCollectionBase is a base class that can be used to more easily implement the
            generic ICollection&lt;T&gt; and non-generic ICollection interfaces for a read-only collection:
            a collection that does not allow adding or removing elements.
            </summary>
            <remarks>
            <para>To use ReadOnlyCollectionBase as a base class, the derived class must override
            the Count and GetEnumerator methods. </para>
            <para>ICollection&lt;T&gt;.Contains need not be implemented by the
            derived class, but it should be strongly considered, because the ReadOnlyCollectionBase implementation
            may not be very efficient.</para>
            </remarks>
            <typeparam name="T">The item type of the collection.</typeparam>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyCollectionBase`1.DebuggerDisplayString">
            <summary>
            Display the contents of the collection in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
            <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyCollectionBase`1.ToString">
            <summary>
            Shows the string representation of the collection. The string representation contains
            a list of the items in the collection.
            </summary>
            <returns>The string representation of the collection.</returns>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyCollectionBase`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            This method throws an NotSupportedException
            stating the collection is read-only.
            </summary>
            <param name="item">Item to be added to the collection.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyCollectionBase`1.System#Collections#Generic#ICollection{T}#Clear">
            <summary>
            This method throws an NotSupportedException
            stating the collection is read-only.
            </summary>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyCollectionBase`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <summary>
            This method throws an NotSupportedException
            stating the collection is read-only.
            </summary>
            <param name="item">Item to be removed from the collection.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyCollectionBase`1.Contains(`0)">
            <summary>
            Determines if the collection contains a particular item. This default implementation
            iterates all of the items in the collection via GetEnumerator, testing each item
            against <paramref name="item"/> using IComparable&lt;T&gt;.Equals or
            Object.Equals.
            </summary>
            <remarks>You should strongly consider overriding this method to provide
            a more efficient implementation.</remarks>
            <param name="item">The item to check for in the collection.</param>
            <returns>True if the collection contains <paramref name="item"/>, false otherwise.</returns>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyCollectionBase`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies all the items in the collection into an array. Implemented by
            using the enumerator returned from GetEnumerator to get all the items
            and copy them to the provided array.
            </summary>
            <param name="array">Array to copy to.</param>
            <param name="arrayIndex">Starting index in <paramref name="array"/> to copy to.</param>
        </member>
        <member name="P:Mozart.Collections.ReadOnlyCollectionBase`1.Count">
            <summary>
            Must be overridden to provide the number of items in the collection.
            </summary>
            <value>The number of items in the collection.</value>
        </member>
        <member name="P:Mozart.Collections.ReadOnlyCollectionBase`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Indicates whether the collection is read-only. Returns the value
            of readOnly that was provided to the constructor.
            </summary>
            <value>Always true.</value>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyCollectionBase`1.ToArray">
            <summary>
            Creates an array of the correct size, and copies all the items in the 
            collection into the array, by calling CopyTo.
            </summary>
            <returns>An array containing all the elements in the collection, in order.</returns>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyCollectionBase`1.GetEnumerator">
            <summary>
            Must be overridden to enumerate all the members of the collection.
            </summary>
            <returns>A generic IEnumerator&lt;T&gt; that can be used
            to enumerate all the items in the collection.</returns>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyCollectionBase`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies all the items in the collection into an array. Implemented by
            using the enumerator returned from GetEnumerator to get all the items
            and copy them to the provided array.
            </summary>
            <param name="array">Array to copy to.</param>
            <param name="index">Starting index in <paramref name="array"/> to copy to.</param>
        </member>
        <member name="P:Mozart.Collections.ReadOnlyCollectionBase`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Indicates whether the collection is synchronized.
            </summary>
            <value>Always returns false, indicating that the collection is not synchronized.</value>
        </member>
        <member name="P:Mozart.Collections.ReadOnlyCollectionBase`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Indicates the synchronization object for this collection.
            </summary>
            <value>Always returns this.</value>
        </member>
        <member name="M:Mozart.Collections.ReadOnlyCollectionBase`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Provides an IEnumerator that can be used to iterate all the members of the
            collection. This implementation uses the IEnumerator&lt;T&gt; that was overridden
            by the derived classes to enumerate the members of the collection.
            </summary>
            <returns>An IEnumerator that can be used to iterate the collection.</returns>
        </member>
        <member name="T:Mozart.Collections.SortedMultiDictionary`2">
             <summary>
             <para>The SortedMultiDictionary class that associates values with a key. Unlike an OrderedDictionary,
             each key can have multiple values associated with it. When indexing an OrderedMultidictionary, instead
             of a single value associated with a key, you retrieve an enumeration of values.</para>
             <para>All of the key are stored in sorted order. Also, the values associated with a given key 
             are kept in sorted order as well.</para>
             <para>When constructed, you can chose to allow the same value to be associated with a key multiple
             times, or only one time. </para>
             </summary>
             <typeparam name="TKey">The type of the keys.</typeparam>
             <typeparam name="TValue">The of values associated with the keys.</typeparam>
            <seealso cref="T:Mozart.Collections.MultiDictionary`2"/>
            <seealso cref="!:OrderedDictionary&lt;TKey,TValue&gt;"/>
        </member>
        <member name="T:Mozart.Collections.SortedMultiDictionary`2.View">
             <summary>
             The SortedMultiDictionary&lt;TKey,TValue&gt;.View class is used to look at a subset of the keys and values
             inside an ordered multi-dictionary. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods. 
             </summary>
            <remarks>
             <p>Views are dynamic. If the underlying dictionary changes, the view changes in sync. If a change is made
             to the view, the underlying dictionary changes accordingly.</p>
            <p>Typically, this class is used in conjunction with a foreach statement to enumerate the keys
             and values in a subset of the SortedMultiDictionary. For example:</p>
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, to)) {
                // process pair
             }
            </code>
            </remarks>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.View.#ctor(Mozart.Collections.SortedMultiDictionary{`0,`1},System.Func{System.Collections.Generic.KeyValuePair{`0,`1},System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Initialize the View.
            </summary>
            <param name="myDictionary">Associated SortedMultiDictionary to be viewed.</param>
            <param name="rangeTester">Range tester that defines the range being used.</param>
            <param name="entireTree">If true, then rangeTester defines the entire tree.</param>
            <param name="reversed">Is the view enuemerated in reverse order?</param>
        </member>
        <member name="P:Mozart.Collections.SortedMultiDictionary`2.View.Count">
            <summary>
            Number of keys in this view.
            </summary>
            <value>Number of keys that lie within the bounds the view.</value>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.View.ContainsKey(`0)">
            <summary>
            Tests if the key is present in the part of the dictionary being viewed.
            </summary>
            <param name="key">Key to check</param>
            <returns>True if the key is within this view. </returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.View.Contains(`0,`1)">
            <summary>
            Tests if the key-value pair is present in the part of the dictionary being viewed.
            </summary>
            <param name="key">Key to check for.</param>
            <param name="value">Value to check for.</param>
            <returns>True if the key-value pair is within this view. </returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.View.Add(`0,`1)">
            <summary>
            Adds the given key-value pair to the underlying dictionary of this view.
            If <paramref name="key"/> is not within the range of this view, an
            ArgumentException is thrown.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <exception cref="T:System.ArgumentException"><paramref name="key"/> is not 
            within the range of this view.</exception>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.View.Remove(`0)">
            <summary>
            Removes the key (and associated value) from the underlying dictionary of this view. If
            no key in the view is equal to the passed key, the dictionary and view are unchanged.
            </summary>
            <param name="key">The key to remove.</param>
            <returns>True if the key was found and removed. False if the key was not found.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.View.Remove(`0,`1)">
            <summary>
            Removes the key and value from the underlying dictionary of this view. that is equal to the passed in key. If
            no key in the view is equal to the passed key, or has the given value associated with it, the dictionary and view are unchanged.
            </summary>
            <param name="key">The key to remove.</param>
            <param name="value">The value to remove.</param>
            <returns>True if the key-value pair was found and removed. False if the key-value pair was not found.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.View.Clear">
            <summary>
            Removes all the keys and values within this view from the underlying SortedMultiDictionary.
            </summary>
            <example>The following removes all the keys that start with "A" from an SortedMultiDictionary.
            <code>
            dictionary.Range("A", "B").Clear();
            </code>
            </example>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.View.Reverse">
            <summary>
            Creates a new View that has the same keys and values as this, in the reversed order.
            </summary>
            <returns>A new View that has the reversed order of this view.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.View.EnumerateKeys">
            <summary>
            Enumerate all the keys in the dictionary. 
            </summary>
            <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the collection that
            have at least one value associated with them.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.View.TryEnumerateValues(`0,System.Collections.Generic.IEnumerator{`1}@)">
            <summary>
            Enumerate all of the values associated with a given key. If the key exists and has values associated with it, an enumerator for those
            values is returned throught <paramref name="values"/>. If the key does not exist, false is returned.
            </summary>
            <param name="key">The key to get values for.</param>
            <param name="values">If true is returned, this parameter receives an enumerators that
            enumerates the values associated with that key.</param>
            <returns>True if the key exists and has values associated with it. False otherwise.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.View.CountValues(`0)">
            <summary>
            Gets the number of values associated with a given key.
            </summary>
            <param name="key">The key to count values of.</param>
            <returns>The number of values associated with <paramref name="key"/>. If <paramref name="key"/>
            is not present in this view, zero is returned.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.View.KeyInView(`0)">
            <summary>
            Determine if the given key lies within the bounds of this view.
            </summary>
            <param name="key">Key to test.</param>
            <returns>True if the key is within the bounds of this view.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.NewPair(`0,`1)">
            <summary>
            Helper function to create a new KeyValuePair struct.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns>A new KeyValuePair.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.KeyRange(`0)">
            <summary>
            Get a RangeTester that maps to the range of all items with the 
            given key.
            </summary>
            <param name="key">Key in the given range.</param>
            <returns>A RangeTester delegate that selects the range of items with that range.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.DoubleBoundedKeyRangeTester(`0,System.Boolean,`0,System.Boolean)">
            <summary>
            Gets a range tester that defines a range by first and last items.
            </summary>
            <param name="first">The lower bound.</param>
            <param name="firstInclusive">True if the lower bound is inclusive, false if exclusive.</param>
            <param name="last">The upper bound.</param>
            <param name="lastInclusive">True if the upper bound is inclusive, false if exclusive.</param>
            <returns>A RangeTester delegate that tests for a key in the given range.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.LowerBoundedKeyRangeTester(`0,System.Boolean)">
            <summary>
            Gets a range tester that defines a range by a lower bound.
            </summary>
            <param name="first">The lower bound.</param>
            <param name="inclusive">True if the lower bound is inclusive, false if exclusive.</param>
            <returns>A RangeTester delegate that tests for a key in the given range.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.UpperBoundedKeyRangeTester(`0,System.Boolean)">
            <summary>
            Gets a range tester that defines a range by upper bound.
            </summary>
            <param name="last">The upper bound.</param>
            <param name="inclusive">True if the upper bound is inclusive, false if exclusive.</param>
            <returns>A RangeTester delegate that tests for a key in the given range.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.#ctor(System.Boolean)">
            <summary>
            Create a new SortedMultiDictionary. The default ordering of keys and values are used. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
            <remarks>The default ordering of keys and values will be used, as defined by TKey and TValue's implementation
            of IComparable&lt;T&gt; (or IComparable if IComparable&lt;T&gt; is not implemented). If a different ordering should be
            used, other constructors allow a custom Comparer or IComparer to be passed to changed the ordering.</remarks>
            <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
            <exception cref="T:System.InvalidOperationException">TKey or TValue does not implement either IComparable&lt;T&gt; or IComparable.</exception>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.#ctor(System.Boolean,System.Comparison{`0})">
            <summary>
            Create a new SortedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
            <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
            <param name="keyComparison">A delegate to a method that will be used to compare keys.</param>
            <exception cref="T:System.InvalidOperationException">TValue does not implement either IComparable&lt;TValue&gt; or IComparable.</exception>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.#ctor(System.Boolean,System.Comparison{`0},System.Comparison{`1})">
            <summary>
            Create a new SortedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
            <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
            <param name="keyComparison">A delegate to a method that will be used to compare keys.</param>
            <param name="valueComparison">A delegate to a method that will be used to compare values.</param>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new SortedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
            <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
            <param name="keyComparer">An IComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
            <exception cref="T:System.InvalidOperationException">TValue does not implement either IComparable&lt;TValue&gt; or IComparable.</exception>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IComparer{`0},System.Collections.Generic.IComparer{`1})">
            <summary>
            Create a new SortedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
            <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
            <param name="keyComparer">An IComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
            <param name="valueComparer">An IComparer&lt;TValue&gt; instance that will be used to compare values.</param>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.#ctor(System.Boolean,System.Int32,System.Collections.Generic.IComparer{`0},System.Collections.Generic.IComparer{`1},System.Collections.Generic.IComparer{System.Collections.Generic.KeyValuePair{`0,`1}},Mozart.Collections.RBTree{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Create a new SortedMultiDictionary. Used internally for cloning.
            </summary>
            <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
            <param name="keyCount">Number of keys.</param>
            <param name="keyComparer">An IComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
            <param name="valueComparer">An IComparer&lt;TValue&gt; instance that will be used to compare values.</param>
            <param name="comparer">Comparer of key-value pairs.</param>
            <param name="tree">The red-black tree used to store the data.</param>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.Add(`0,`1)">
            <summary>
            <para>Adds a new value to be associated with a key. If duplicate values are permitted, this
            method always adds a new key-value pair to the dictionary.</para>
            <para>If duplicate values are not permitted, and <paramref name="key"/> already has a value
            equal to <paramref name="value"/> associated with it, then that value is replaced with <paramref name="value"/>,
            and the number of values associate with <paramref name="key"/> is unchanged.</para>
            </summary>
            <param name="key">The key to associate with.</param>
            <param name="value">The value to associated with <paramref name="key"/>.</param>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.Remove(`0,`1)">
            <summary>
            Removes a given value from the values associated with a key. If the
            last value is removed from a key, the key is removed also.
            </summary>
            <param name="key">A key to remove a value from.</param>
            <param name="value">The value to remove.</param>
            <returns>True if <paramref name="value"/> was associated with <paramref name="key"/> (and was
            therefore removed). False if <paramref name="value"/> was not associated with <paramref name="key"/>.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.Remove(`0)">
            <summary>
            Removes a key and all associated values from the dictionary. If the
            key is not present in the dictionary, it is unchanged and false is returned.
            </summary>
            <param name="key">The key to remove.</param>
            <returns>True if the key was present and was removed. Returns 
            false if the key was not present.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.Clear">
            <summary>
            Removes all keys and values from the dictionary.
            </summary>
        </member>
        <member name="P:Mozart.Collections.SortedMultiDictionary`2.KeyComparer">
            <summary>
            Returns the IComparer&lt;T&gt; used to compare keys in this dictionary. 
            </summary>
            <value>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for TKey (Comparer&lt;TKey&gt;.Default) is returned.</value>
        </member>
        <member name="P:Mozart.Collections.SortedMultiDictionary`2.ValueComparer">
            <summary>
            Returns the IComparer&lt;T&gt; used to compare values in this dictionary. 
            </summary>
            <value>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for TValue (Comparer&lt;TValue&gt;.Default) is returned.</value>
        </member>
        <member name="P:Mozart.Collections.SortedMultiDictionary`2.Count">
            <summary>
            Gets the number of key-value pairs in the dictionary. Each value associated
            with a given key is counted. If duplicate values are permitted, each duplicate
            value is included in the count.
            </summary>
            <value>The number of key-value pairs in the dictionary.</value>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.Contains(`0,`1)">
            <summary>
            Checks to see if <paramref name="value"/> is associated with <paramref name="key"/>
            in the dictionary.
            </summary>
            <param name="key">The key to check.</param>
            <param name="value">The value to check.</param>
            <returns>True if <paramref name="value"/> is associated with <paramref name="key"/>.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.ContainsKey(`0)">
            <summary>
            Checks to see if the key is present in the dictionary and has
            at least one value associated with it.
            </summary>
            <param name="key">The key to check.</param>
            <returns>True if <paramref name="key"/> is present and has at least
            one value associated with it. Returns false otherwise.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.EqualValues(`1,`1)">
            <summary>
            Determine if two values are equal.
            </summary>
            <param name="value1">First value to compare.</param>
            <param name="value2">Second value to compare.</param>
            <returns>True if the values are equal.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.TryEnumerateValues(`0,System.Collections.Generic.IEnumerator{`1}@)">
            <summary>
            Determines if this dictionary contains a key equal to <paramref name="key"/>. If so, all the values
            associated with that key are returned through the values parameter. 
            </summary>
            <param name="key">The key to search for.</param>
            <param name="values">Returns all values associated with key, if true was returned.</param>
            <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.EnumerateKeys">
            <summary>
            Enumerate all of the keys in the dictionary.
            </summary>
            <returns>An IEnumerator&lt;TKey&gt; of all of the keys in the dictionary.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.CountValues(`0)">
            <summary>
            Gets the number of values associated with a given key.
            </summary>
            <param name="key">The key to count values of.</param>
            <returns>The number of values associated with <paramref name="key"/>. If <paramref name="key"/>
            is not present in the dictionary, zero is returned.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.CountAllValues">
            <summary>
            Gets a total count of values in the collection. 
            </summary>
            <returns>The total number of values associated with all keys in the dictionary.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.EnumerateKeys(System.Func{System.Collections.Generic.KeyValuePair{`0,`1},System.Int32},System.Boolean)">
            <summary>
            A private helper method that returns an enumerable that
            enumerates all the keys in a range.
            </summary>
            <param name="rangeTester">Defines the range to enumerate.</param>
            <param name="reverse">Should the keys be enumerated in reverse order?</param>
            <returns>An IEnumerable&lt;TKey&gt; that enumerates the keys in the given range.
            in the dictionary.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.EnumerateValues(`0)">
            <summary>
            A private helper method for the indexer to return an enumerable that
            enumerates all the values for a key. This is separate method because indexers
            can't use the yield return construct.
            </summary>
            <param name="key"></param>
            <returns>An IEnumerable&lt;TValue&gt; that can be used to enumerate all the
            values associated with <paramref name="key"/>. If <paramref name="key"/> is not present,
            an enumerable that enumerates no items is returned.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.System#ICloneable#Clone">
            <summary>
            Implements ICloneable.Clone. Makes a shallow clone of this dictionary; i.e., if keys or values are reference types, then they are not cloned.
            </summary>
            <returns>The cloned dictionary.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.Clone">
            <summary>
            Makes a shallow clone of this dictionary; i.e., if keys or values of the
            dictionary are reference types, then they are not cloned. If TKey or TValue is a value type,
            then each element is copied as if by simple assignment.
            </summary>
            <remarks>Cloning the dictionary takes time O(N), where N is the number of key-value pairs in the dictionary.</remarks>
            <returns>The cloned dictionary.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.CloneContents">
            <summary>
            Makes a deep clone of this dictionary. A new dictionary is created with a clone of
            each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is
            a value type, then each element is copied as if by simple assignment.
            </summary>
            <remarks><para>If TKey or TValue is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
            <para>Cloning the dictionary takes time O(N log N), where N is the number of key-value pairs in the dictionary.</para></remarks>
            <returns>The cloned dictionary.</returns>
            <exception cref="T:System.InvalidOperationException">TKey or TValue is a reference type that does not implement ICloneable.</exception>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.Reverse">
             <summary>
             Returns a View collection that can be used for enumerating the keys and values in the collection in 
             reversed order.
             </summary>
            <remarks>
            <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Reversed()) {
                // process pair
             }
            </code></p>
             <p>If an entry is added to or deleted from the dictionary while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
            <p>Calling Reverse does not copy the data in the dictionary, and the operation takes constant time.</p>
            </remarks>
             <returns>An OrderedDictionary.View of key-value pairs in reverse order.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.Range(`0,System.Boolean,`0,System.Boolean)">
             <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only keys that are greater than <paramref name="from"/> and 
             less than <paramref name="to"/> are included. The keys are enumerated in sorted order.
             Keys equal to the end points of the range can be included or excluded depending on the
             <paramref name="fromInclusive"/> and <paramref name="toInclusive"/> parameters.
             </summary>
            <remarks>
            <p>If <paramref name="from"/> is greater than or equal to <paramref name="to"/>, the returned collection is empty. </p>
            <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
            <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, true, to, false)) {
                // process pair
             }
            </code>
            <p>Calling Range does not copy the data in the dictionary, and the operation takes constant time.</p></remarks>
             <param name="from">The lower bound of the range.</param>
             <param name="fromInclusive">If true, the lower bound is inclusive--keys equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
             be included in the range.</param>
             <param name="to">The upper bound of the range. </param>
             <param name="toInclusive">If true, the upper bound is inclusive--keys equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
             be included in the range.</param>
             <returns>An SortedMultiDictionary.View of key-value pairs in the given range.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.RangeFrom(`0,System.Boolean)">
             <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only keys that are greater than (and optionally, equal to) <paramref name="from"/> are included. 
             The keys are enumerated in sorted order. Keys equal to <paramref name="from"/> can be included
             or excluded depending on the <paramref name="fromInclusive"/> parameter.
             </summary>
            <remarks>
            <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
            <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, true)) {
                // process pair
             }
            </code>
            <p>Calling RangeFrom does not copy of the data in the dictionary, and the operation takes constant time.</p>
            </remarks>
             <param name="from">The lower bound of the range.</param>
             <param name="fromInclusive">If true, the lower bound is inclusive--keys equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
             be included in the range.</param>
             <returns>An SortedMultiDictionary.View of key-value pairs in the given range.</returns>
        </member>
        <member name="M:Mozart.Collections.SortedMultiDictionary`2.RangeTo(`0,System.Boolean)">
             <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only items that are less than (and optionally, equal to) <paramref name="to"/> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="to"/> can be included
             or excluded depending on the <paramref name="toInclusive"/> parameter.
             </summary>
            <remarks>
            <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
            <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, false)) {
                // process pair
             }
            </code>
            <p>Calling RangeTo does not copy the data in the dictionary, and the operation takes constant time.</p>
            </remarks>
             <param name="to">The upper bound of the range. </param>
             <param name="toInclusive">If true, the upper bound is inclusive--keys equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
             be included in the range.</param>
             <returns>An SortedMultiDictionary.View of key-value pairs in the given range.</returns>
        </member>
        <member name="T:Mozart.Collections.BigList`1">
            <summary>
             *Resizable Arrays in Optimal Time and Space*
            maintains multiple sublists each having size O(sqrt(this.Count)), giving a
            reasonable upper bound on the size of any one contiguous memory block
            consumed by an instance. Furthermore, the resizing approach taken by this
             data structure guarantees a memory overhead of O(sqrt(this.Count)) instead
             of the O(this.Count) overhead that is typical of resizable array
             implementations (including ArrayList) while maintaining O(1) amortized time
             add and remove operations; the data structure is <em>compact</em> in the
             sense that this is theoretically optimal [ResizableArraysTR]. In addition,
             this data structure achieves O(sqrt(this.Count)) time middle
             insertion/deletion by maintaining circular lists throughout.    
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Mozart.Collections.BigList`1.CheckCapacity">
            <summary>
            Manipulate the state of this instance appropriately if its capacity has
            fallen outside of either capacity limit.
            </summary>
        </member>
        <member name="M:Mozart.Collections.BigList`1.MergeNextSmallSublists">
            <summary>
            Merge two small sublists to a single large sublist if two small sublists	 
            exist, or double the capacity of the single small sublist to that of a	 
            large sublist if only a single small sublist exists. Do nothing if no	 
            small sublists exist.
            </summary>
        </member>
        <member name="M:Mozart.Collections.BigList`1.SplitNextLargeSublist">
            <summary>
             Splits a large sublist into two small sublists. If one of the small         
             sublists is empty, then it is discarded. No operation is performed if no         
             large sublists exist.
            </summary>
        </member>
        <member name="P:Mozart.Collections.BitVector64.Item(System.Int64)">
            <summary>
            Determines whether the bit, corresponding to the specified key is set
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Mozart.Collections.BitVector64.Data">
            <summary>
            Gets the UInt64 structure holding the separate bits of the vector.
            </summary>
        </member>
        <member name="M:Mozart.Collections.BitVector64.Reset">
            <summary>
            Clears all currently set bits in this vector.
            </summary>
        </member>
        <member name="T:Mozart.Collections.IndexedSkipList`1">
            <summary>
            maxLevel=(int)Math.Ceiling(Math.Log((double)maxNodes)/Math.Log(1.0/0.25))-1;
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Mozart.Collections.IndexedSkipList`1.PickRandomLevel">
            <summary>
            This uses a cheap pseudo-random function that according to
            http://home1.gte.net/deleyd/random/random4.html was used in
            Turbo Pascal. It seems the fastest usable one here. The low
            bits are apparently not very random (the original used only
            upper 16 bits) so we traverse from highest bit down (i.e., test
            sign), thus hardly ever use lower bits.
            </summary>
            <returns>Returns a random level for inserting a new node.
            Hardwired to k=1, p=0.5, max 31.</returns>
        </member>
        <member name="T:Mozart.Collections.IntervalHeap`1">
            <summary>
            A double-ended priority queue
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Mozart.Collections.MergeSort">
            <summary>
            Provides a stable array sort based on merge-sort using O(n) additional memory.  As a release build,
            this routine will operate faster than Array.Sort when using a custom (non-default) comparison.  It
            also has the advantange of being stable, that is it preserves the order of elements that compare as
            being of equal value.
            </summary>
        </member>
        <member name="M:Mozart.Collections.MergeSort.Sort``1(``0[])">
            <summary> Sorts the contents of the array using a stable merge-sort with O(n) additional memory </summary>
        </member>
        <member name="M:Mozart.Collections.MergeSort.Sort``1(``0[],``0[]@,System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary> Sorts the contents of the array using a stable merge-sort with O(n) additional memory </summary>
            <remarks> This overload also yields the working copy of the array which is unsorted. </remarks>
        </member>
        <member name="M:Mozart.Collections.MergeSort.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary> Sorts the contents of the array using a stable merge-sort with O(n) additional memory </summary>
        </member>
        <member name="M:Mozart.Collections.MergeSort.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary> Sorts the contents of the array using a stable merge-sort with O(n) additional memory </summary>
        </member>
        <member name="M:Mozart.Collections.MergeSort.Sort``1(``0[],System.Comparison{``0})">
            <summary> Sorts the contents of the array using a stable merge-sort with O(n) additional memory </summary>
        </member>
        <member name="M:Mozart.Collections.MergeSort.Sort``1(``0[],System.Int32,System.Int32,System.Comparison{``0})">
            <summary> Sorts the contents of the array using a stable merge-sort with O(n) additional memory </summary>
        </member>
        <member name="T:Mozart.Collections.BitList">
            <summary>
            An ordinal list(bit-set) is a list optimized to store lists of integer data that can then be manipulated 
            as a set with intersect/union etc.  Each integer stored is translated to a bit offset and thus
            cann't be stored more than once or in any particular order.  Note: adding the value int.Max will 
            allocate int.Max/8 bytes of memory, so this is best used with ordinal indexes into a list that 
            is smaller than 8,388,608 (one megabyte of bits).  Pre-allocate with Ceiling = max for better
            performance, or add the integers in reverse order (highest to lowest).
            
            https://svn.apache.org/repos/asf/lucene.net/tags/Lucene.Net_3_0_3_RC2_final/src/core/Util/BitVector.cs
            </summary>
        </member>
        <member name="M:Mozart.Collections.BitList.#ctor">
            <summary> Constructs an empty OrdinalList </summary>
        </member>
        <member name="M:Mozart.Collections.BitList.#ctor(System.Byte[])">
            <summary> Constructs an OrdinalList from a set of bits represeting the ordinals </summary>
        </member>
        <member name="M:Mozart.Collections.BitList.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary> Constructs an OrdinalList from the integer ordinals provided </summary>
        </member>
        <member name="M:Mozart.Collections.BitList.Clear">
            <summary> Empty the OrdinalList </summary>
        </member>
        <member name="P:Mozart.Collections.BitList.Count">
            <summary> Semi-expensive, returns the count of ordinals in the collection </summary>
        </member>
        <member name="P:Mozart.Collections.BitList.Ceiling">
            <summary> 
            Gets or sets the maximum inclusive ordinal that can be stored in the memory currently
            allocated, ranges from -1 to int.MaxValue
            </summary>
        </member>
        <member name="M:Mozart.Collections.BitList.AddRange(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary> Adds a range of integer ordinals into the collection </summary>
        </member>
        <member name="M:Mozart.Collections.BitList.Add(System.Int32)">
            <summary> Adds an integer ordinal into the collection </summary>
        </member>
        <member name="M:Mozart.Collections.BitList.Remove(System.Int32)">
            <summary> Removes an ordinal from the collection </summary>
        </member>
        <member name="M:Mozart.Collections.BitList.Contains(System.Int32)">
            <summary> Returns true if the ordinal is in the collection </summary>
        </member>
        <member name="M:Mozart.Collections.BitList.CopyTo(System.Int32[],System.Int32)">
            <summary> Extracts the ordinals into an array </summary>
        </member>
        <member name="P:Mozart.Collections.BitList.IsReadOnly">
            <summary> Returns false </summary>
        </member>
        <member name="M:Mozart.Collections.BitList.ToArray">
            <summary> Returns the array of ordinals that have been added. </summary>
        </member>
        <member name="M:Mozart.Collections.BitList.ToByteArray">
            <summary> Returns the complete set of raw bytes for storage and reconstitution </summary>
        </member>
        <member name="M:Mozart.Collections.BitList.Invert(System.Int32)">
            <summary> Returns the 1's compliment (inverts) of the list up to Ceiling </summary>
        </member>
        <member name="M:Mozart.Collections.BitList.IntersectWith(Mozart.Collections.BitList)">
            <summary> Returns the set of items that are in both this set and the provided set </summary>
            <example>{ 1, 2, 3 }.IntersectWith({ 2, 3, 4 }) == { 2, 3 }</example>
        </member>
        <member name="M:Mozart.Collections.BitList.UnionWith(Mozart.Collections.BitList)">
            <summary> Returns the set of items that are in either this set or the provided set </summary>
            <example>{ 1, 2, 3 }.UnionWith({ 2, 3, 4 }) == { 1, 2, 3, 4 }</example>
        </member>
        <member name="M:Mozart.Collections.BitList.Enumerate(System.Int32)">
            <summary> Returns an enumeration of the ordinal values </summary>
        </member>
        <member name="M:Mozart.Collections.BitList.GetEnumerator">
            <summary> Returns an enumeration of the ordinal values </summary>
        </member>
        <member name="M:Mozart.Collections.BitList.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.#ctor(System.Boolean)">
            <summary>
            Tree constructor
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.#ctor(System.Collections.Generic.IComparer{`0},System.Boolean)">
            <summary>
            Tree constructor with comparer
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.Add(`0)">
            <summary>
            Add new key into the tree if not present in unique mode
            
            This operation is O(logN) operation
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.Remove(`0)">
            <summary>
            Remove key from the dictionary
            This operation is O(logN) operation
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.RemoveRange(System.Func{`0,System.Int32})">
            <summary>
            Delete all the items in a range, identified by a RangeTester delegate.
            </summary>
            <param name="rangeTester">The delegate that defines the range to delete.</param>
            <returns>The number of items deleted.</returns>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.Clear">
            <summary>
            Remove all items
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.Remove(Mozart.Collections.RBTree{`0}.Node)">
            <summary>
            Remove node from the dictionary
            This operation is O(1) operation
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.Find(`0)">
            <summary>
            Find key in the dictionary
            This operation is O(logN) operation
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.First">
            <summary>
            Get first node
            This operation is O(logN) operation
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.Last">
            <summary>
            Get last node
            This operation is O(logN) operation
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.Next(Mozart.Collections.RBTree{`0}.Node)">
            <summary>
            Get next node
            This operation is O(logN) operation
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.Previous(Mozart.Collections.RBTree{`0}.Node)">
            <summary>
            Get previous node
            This operation is O(logN) operation
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.CountRange(System.Func{`0,System.Int32})">
            <summary>
            Count the items in a custom range in the tree. The range is determined by 
            a RangeTester delegate.
            </summary>
            <param name="rangeTester">The delegate that defines the range.</param>
            <returns>The number of items in the range.</returns>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.CountRange(System.Func{`0,System.Int32},Mozart.Collections.RBTree{`0}.Node,System.Boolean,System.Boolean)">
            <summary>
            Count all the items in a custom range, under and including node.
            </summary>
            <param name="range">The delegate that defines the range.</param>
            <param name="node">Node to begin enumeration. May be null.</param>
            <param name="belowRangeTop">This node and all under it are either in the range or below it.</param>
            <param name="aboveRangeBottom">This node and all under it are either in the range or above it.</param>
            <returns>The number of items in the range, under and include node.</returns>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.InsertFixup(Mozart.Collections.RBTree{`0}.Node)">
            <summary>
            Balance tree past inserting
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.Insert(`0,System.Boolean@)">
            <summary>
            Go trough tree and find the node by the key.
            Might add new node if node doesn't exist.
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.LeftRotate(Mozart.Collections.RBTree{`0}.Node)">
            <summary>
             Rotate our tree Left
            
                         X        rb_left_rotate(X)--->            Y
                       /   \                                     /   \
                      A     Y                                   X     C
                          /   \                               /   \
                         B     C                             A     B
            
             RBTreeNode.B. This does not change the ordering.
            
             We assume that neither X or Y is NULL
             </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.RightRotate(Mozart.Collections.RBTree{`0}.Node)">
            <summary>
             Rotate our tree Right
            
                         X                                         Y
                       /   \                                     /   \
                      A     Y     leftArrow--rb_right_rotate(Y)        X     C
                          /   \                               /   \
                         B     C                             A     B
            
             RBTreeNode.B. This does not change the ordering.
            
             We assume that neither X or Y is NULL
            </summary>>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.Successor(Mozart.Collections.RBTree{`0}.Node)">
            <summary>
            Return a pointer to the smallest key greater than x
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.Predecessor(Mozart.Collections.RBTree{`0}.Node)">
            <summary>
            Return a pointer to the largest key smaller than x
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.Delete(Mozart.Collections.RBTree{`0}.Node)">
            <summary>
            Delete the node z, and free up the space
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.DeleteFixup(Mozart.Collections.RBTree{`0}.Node)">
            <summary>
            Restore the reb-black properties after a delete
            </summary>
            <param name="x"></param>
        </member>
        <member name="P:Mozart.Collections.RBTree`1.Node.SubtreeSize">
            <summary>
            Get or set the SubtreeSize field -- a 31-bit field
            that holds the number of nodes at or below this level.
            </summary>
        </member>
        <member name="P:Mozart.Collections.RBTree`1.Node.IsRed">
            <summary>
            Is this a red node?
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.Clone">
            <summary>
            Clone the tree, returning a new tree containing the same items. Should
            take O(N) take.
            </summary>
            <returns>Clone version of this tree.</returns>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.StopEnumerations">
            <summary>
            Must be called whenever there is a structural change in the tree. Causes
            changeStamp to be changed, which causes any in-progress enumerations
            to throw exceptions.
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.CheckEnumeration(System.Int32)">
            <summary>
            Checks the given stamp against the current change stamp. If different, the
            collection has changed during enumeration and an InvalidOperationException
            must be thrown
            </summary>
            <param name="stamp">version at the start of the enumeration.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Mozart.Collections.RBTree`1.GetViewBetween(`0,`0)" -->
        <member name="M:Mozart.Collections.RBTree`1.SubTree.#ctor">
            <summary>
            For serialization and deserialization
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.SubTree.Insert(`0)">
            <summary>
            Additions to this tree need to be added to the underlying tree as well
            </summary>
        </member>
        <member name="M:Mozart.Collections.RBTree`1.SubTree.VersionCheck">
            <summary>
            checks whether this subset is out of date. updates if necessary.
            </summary>
        </member>
        <member name="T:Mozart.Collections.DoubleDictionary`3">
            <summary>
            This the explanation of DoubleDictionary class having two Keys as a Pair.
            </summary>
            <typeparam name="TKey1">The First Key.</typeparam>
            <typeparam name="TKey2">The Second Key.</typeparam>
            <typeparam name="TValue">Value to be saved.</typeparam>
            <remarks>
            This is the datastructure to save Data by combining two Keys.
            1. The first Key creates and modifies multiple second Keys that do not overlap.
            2. The second Key creates and modifies multiple Values that do not overlap.
            </remarks>
        </member>
        <member name="M:Mozart.Collections.DoubleDictionary`3.#ctor">
            <summary>
            Constructor of DoubleDictionary.
            </summary>
        </member>
        <member name="M:Mozart.Collections.DoubleDictionary`3.#ctor(System.Int32)">
            <summary>
            Constructor of DoubleDictionary. Allocate Dicationary size as much as Capacity size.
            </summary>
            <param name="capacity">The variable to decide the maximum size of Dictionary.</param>
            <remarks>
            If Capacity value is lower than 0, ArgumentOutOfRangeException is called.
            Unless Resizing is required, elements can be included as much as Capacity size..
            </remarks>
        </member>
        <member name="M:Mozart.Collections.DoubleDictionary`3.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Constructor of DoubleDictionary. Allocate Dicationary size as much as Capacity size.
            </summary>
            <param name="capacity">The variable to decide the maximum size of Dictionary.</param>
            <param name="keyComparer1">compare variable to comper Dictionary Key.</param>
            <remarks>
            If Capacity value is lower than 0, ArgumentOutOfRangeException is called.
            Unless Resizing is required, elements can be included as much as Capacity size..
            </remarks>
        </member>
        <member name="P:Mozart.Collections.DoubleDictionary`3.Item(`0,`1)">
            <summary>
            Adds or gets the value linked to the assigned key.
            </summary>
            <param name="key1">The first assigned Key value.</param>
            <param name="key2">The second assigned Key value.</param>
            <returns>Return the corresponding value</returns>
        </member>
        <member name="M:Mozart.Collections.DoubleDictionary`3.Get(`0,`1)">
            <summary>
            Gets the value linked to the assigned key..
            </summary>
            <param name="key1">The first assigned Key value.</param>
            <param name="key2">The second assigned Key value.</param>
            <returns>Return the corresponding value.</returns>
        </member>
        <member name="M:Mozart.Collections.DoubleDictionary`3.Set(`0,`1,`2)">
            <summary>
            Add the assigned Key and value to DoubleDictionary
            </summary>
            <param name="key1">The first assigned Key value.</param>
            <param name="key2">The second assigned Key value.</param>
            <param name="value">Assigned target value.</param>
            <remarks>
            The assigned key value should exist in Dictionary.
            </remarks>
        </member>
        <member name="M:Mozart.Collections.DoubleDictionary`3.ContainsKey(`0,`1)">
            <summary>
            Determines whether the designated key is in DoubleDictionary.
            </summary>
            <param name="key1">The first assigned Key value.</param>
            <param name="key2">The second assigned Key value.</param>
            <returns>
            If there is value linked to the Key value, return true, or else, return false.
            </returns>
        </member>
        <member name="M:Mozart.Collections.DoubleDictionary`3.Add(`0,`1,`2)">
            <summary>
            Add assigned key and value to Dictionary
            </summary>
            <param name="key1">The first assigned Key value.</param>
            <param name="key2">The second assigned Key value.</param>
            <param name="value">Assigned target value.</param>
        </member>
        <member name="M:Mozart.Collections.DoubleDictionary`3.TryAdd(`0,`1,`2)">
            <summary>
            Add assigned key and value to Dictionary
            </summary>
            <param name="key1">The first assigned Key value.</param>
            <param name="key2">The second assigned Key value.</param>
            <param name="value">Assigned target value.</param>
            <returns>
            If the first assigned key is included to Dictionary, return true, if not, return false.
            </returns>
        </member>
        <member name="M:Mozart.Collections.DoubleDictionary`3.TryGetValue(`0,`1,`2@)">
            <summary>
            Get the value linked to the assigned key.
            </summary>
            <param name="key1">The first assigned key value.</param>
            <param name="key2">The second assigned key value.</param>
            <param name="value">Assigned target value.</param>
            <returns>Return the result value whether the value of the key has been received.</returns>
        </member>
        <member name="M:Mozart.Collections.DoubleDictionary`3.GetDictionary(`0)">
            <summary>
            Get the value linked to the assigned key.
            </summary>
            <param name="key1">The first assigned key</param>
            <returns>Return the Dictionary linked to the first assigned key.</returns>
        </member>
        <member name="M:Mozart.Collections.DoubleDictionary`3.GetDictionary(`0,System.Boolean)">
            <summary>
            Get the value linked to the assigned key.
            </summary>
            <param name="key1">The first assigned Key value.</param>
            <param name="create">Determines whether to create key value when it does not exist.</param>
            <remarks>
            If create value is true and there is no value linked to the assigned key, create a new value as Dictionary type.
            </remarks>
            <returns>Return the Dictionary linked to the first assigned key.</returns>
        </member>
        <member name="M:Mozart.Collections.DoubleDictionary`3.Remove(`0,`1)">
            <summary>
            Delete the value linked to the assigned key.
            </summary>
            <param name="key1">The first assigned Key value.</param>
            <param name="key2">The second assigned Key value.</param>
            <returns>Return the deletion result .</returns>
        </member>
        <member name="M:Mozart.Collections.DoubleDictionary`3.Remove(`0,`1,System.Boolean)">
            <summary>
            Delete the value linked to the assigned key.
            </summary>
            <param name="key1">The first assigned Key value.</param>
            <param name="key2">The second assigned Key value.</param>
            <param name="removeIfEmpty">The variable to determine whether to delete if no value exists..</param>
            <returns>Return the deletion result .</returns>
        </member>
        <member name="M:Mozart.Collections.DoubleDictionary`3.GetEnumerator">
            <summary>
            Get the values of the current DoubleDictionary in a sequence.
            </summary>
            <returns>Return value in IEnumerator type.</returns>
        </member>
        <member name="T:Mozart.Configuration.ISettingStore">
            <summary>
            provides a basic inteface for a reader/writer of string name/value pairs
            </summary>
        </member>
        <member name="M:Mozart.Configuration.ISettingStore.Read(System.String,System.String,System.String@)">
            <summary>
            returns true if the property was successfully retireved into the output
            variable 'value'
            </summary>
            <param name="path">Optional path for context information</param>
            <param name="name">The name of the property</param>
            <param name="value">Returns the output value if available</param>
            <returns>true if successful or false if data not available</returns>
        </member>
        <member name="M:Mozart.Configuration.ISettingStore.Write(System.String,System.String,System.String)">
            <summary>
            Writes the given property by name
            </summary>
            <param name="path">Optional path for context information</param>
            <param name="name">The name of the property</param>
            <param name="value">The value to store</param>
        </member>
        <member name="M:Mozart.Configuration.ISettingStore.Delete(System.String,System.String)">
            <summary>
            Removes a property from the storage by name
            </summary>
            <param name="path">Optional path for context information</param>
            <param name="name">The name of the property to remove</param>
        </member>
        <member name="T:Mozart.Configuration.Settings">
            <summary>
            Used with one of the implementations in the StorageClasses namespace, this class
            provides rich-type storage on top of the basic INameValueStore string storage
            container.
            </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.#ctor(Mozart.Configuration.ISettingStore)">
            <summary>
            Constructs a storage wrapper for the given name/value store and sets the initial
            path to the provided value.
            </summary>
            <param name="store">The storage container to use</param>
        </member>
        <member name="M:Mozart.Configuration.Settings.#ctor(Mozart.Configuration.ISettingStore,System.String)">
            <summary>
            Constructs a storage wrapper for the given name/value store and sets the initial
            path to the provided value.
            </summary>
            <param name="store">The storage container to use</param>
            <param name="contextPath">The full context of the storage item, delimit with '/' or '\'</param>
        </member>
        <member name="P:Mozart.Configuration.Settings.ContextPath">
            <summary>
            Retrieves the current context path of the store
            </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetContext(System.String)">
            <summary>
            Replaces the context path of the storage, dispose of the returned IDisposable
            to restore the Storage's previous ContextPath.
            </summary>
            <param name="contextPath">The full context path to change to</param>
            <returns>Context can be disposed to restore the previous state</returns>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.Boolean)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.Byte)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.SByte)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.Char)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.DateTime)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.TimeSpan)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.Decimal)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.Double)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.Single)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.Guid)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.Uri)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.Int16)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.UInt16)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.Int32)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.UInt32)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.Int64)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.UInt64)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.String)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.Version)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.GetValue(System.String,System.Type,System.Object)">
            <summary> Retrieves the named defaultValue from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.Boolean@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.Byte@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.SByte@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.Char@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.DateTime@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.TimeSpan@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.Decimal@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.Double@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.Single@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.Guid@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.Uri@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.Int16@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.UInt16@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.Int32@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.UInt32@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.Int64@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.UInt64@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.String@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.Version@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.TryGetValue(System.String,System.Type,System.Object@)">
            <summary> Retrieves the named value from the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.Boolean)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.Byte)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.SByte)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.Char)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.DateTime)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.TimeSpan)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.Decimal)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.Double)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.Single)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.Guid)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.Uri)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.Int16)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.UInt16)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.Int32)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.UInt32)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.Int64)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.UInt64)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.String)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.Version)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.SetValue(System.String,System.Type,System.Object)">
            <summary> Writes/Replaces the named value in the storage </summary>
        </member>
        <member name="M:Mozart.Configuration.Settings.Delete(System.String)">
            <summary> Removes the named value from the storage </summary>
        </member>
        <member name="T:Mozart.Configuration.RegistryStorage">
            <summary>
            Stores values in the registry at HKCU\Software\{Company}\{Product} path.
            </summary>
        </member>
        <member name="M:Mozart.Configuration.RegistryStorage.#ctor">
            <summary>
            Stores values in the registry at HKCU\Software\{Company}\{Product} path.
            </summary>
        </member>
        <member name="M:Mozart.Configuration.RegistryStorage.#ctor(System.String)">
            <summary>
            Stores values in the registry at HKCU\Software\{Company}\{Product} path.
            </summary>
        </member>
        <member name="M:Mozart.Configuration.RegistryStorage.#ctor(Microsoft.Win32.RegistryKey,System.String)">
            <summary>
            Stores values in the registry at path.
            </summary>
        </member>
        <member name="M:Mozart.Configuration.RegistryStorage.Read(System.String,System.String,System.String@)">
            <summary>
            returns true if the property was successfully retireved into the output
            variable 'value'
            </summary>
        </member>
        <member name="M:Mozart.Configuration.RegistryStorage.Write(System.String,System.String,System.String)">
            <summary>
            Writes the given property by name
            </summary>
        </member>
        <member name="M:Mozart.Configuration.RegistryStorage.Delete(System.String,System.String)">
            <summary>
            Removes a property from the storage by name
            </summary>
        </member>
        <member name="T:Mozart.Configuration.IsolatedStorage">
            <summary>
            Stores values in the IsolatedStorage for the application in {Company}\{Product} path.
            </summary>
        </member>
        <member name="M:Mozart.Configuration.IsolatedStorage.#ctor">
            <summary>
            Stores values in the IsolatedStorage for the application in {Company}\{Product} path.
            </summary>
        </member>
        <member name="M:Mozart.Configuration.IsolatedStorage.#ctor(System.String,System.Boolean)">
            <summary>
            Stores values in the IsolatedStorage for the application in path.
            </summary>
        </member>
        <member name="M:Mozart.Configuration.IsolatedStorage.Read(System.String,System.String,System.String@)">
            <summary>
            returns true if the property was successfully retireved into the output
            variable 'value'
            </summary>
        </member>
        <member name="M:Mozart.Configuration.IsolatedStorage.Write(System.String,System.String,System.String)">
            <summary>
            Writes the given property by name
            </summary>
        </member>
        <member name="M:Mozart.Configuration.IsolatedStorage.Append(System.String,System.String,System.String)">
            <summary>
            Writes the given property by name. If file already exist, value will be appended at last.
            </summary>
        </member>
        <member name="M:Mozart.Configuration.IsolatedStorage.Delete(System.String,System.String)">
            <summary>
            Removes a property from the storage by name
            </summary>
        </member>
        <member name="T:Mozart.Configuration.FileStorage">
            <summary>
            Stores values in the local %AppData% folder in the path {Company}\{Product}.
            </summary>
        </member>
        <member name="M:Mozart.Configuration.FileStorage.#ctor">
            <summary>
            Stores values in the local %AppData% folder in the path {Company}\{Product}.
            </summary>
        </member>
        <member name="M:Mozart.Configuration.FileStorage.#ctor(System.String)">
            <summary>
            Stores values in the local %AppData% folder in the path {Company}\{Product}.
            </summary>
        </member>
        <member name="M:Mozart.Configuration.FileStorage.Read(System.String,System.String,System.String@)">
            <summary>
            returns true if the property was successfully retireved into the output
            variable 'value'
            </summary>
        </member>
        <member name="M:Mozart.Configuration.FileStorage.Write(System.String,System.String,System.String)">
            <summary>
            Writes the given property by name
            </summary>
        </member>
        <member name="M:Mozart.Configuration.FileStorage.Delete(System.String,System.String)">
            <summary>
            Removes a property from the storage by name
            </summary>
        </member>
        <member name="T:Mozart.Configuration.AppSettingStorage">
            <summary>
            Stores values in the local application's configuration section: "AppSettings"
            </summary>
        </member>
        <member name="F:Mozart.Configuration.AppSettingStorage.Sync">
            <summary>
            Provides syncronization across instances of AppSettingsStorage classes
            modifying the configuration file(s)
            </summary>
        </member>
        <member name="M:Mozart.Configuration.AppSettingStorage.#ctor">
            <summary>
            Stores values in the local application's configuration
            </summary>
        </member>
        <member name="M:Mozart.Configuration.AppSettingStorage.MakePath(System.String,System.String)">
            <summary>
            Creates the full name of the item from path and name
            </summary>
        </member>
        <member name="M:Mozart.Configuration.AppSettingStorage.Open(System.String,System.Configuration.Configuration@)">
            <summary>
            Opens a configuration section and returns the key/value collection associated.
            </summary>
        </member>
        <member name="M:Mozart.Configuration.AppSettingStorage.Read(System.String,System.String,System.String@)">
            <summary>
            returns true if the property was successfully retireved into the output
            variable 'value'
            </summary>
        </member>
        <member name="M:Mozart.Configuration.AppSettingStorage.Write(System.String,System.String,System.String)">
            <summary>
            Writes the given property by name
            </summary>
        </member>
        <member name="M:Mozart.Configuration.AppSettingStorage.Delete(System.String,System.String)">
            <summary>
            Removes a property from the storage by name
            </summary>
        </member>
        <member name="T:Mozart.Configuration.DictionaryStorage">
            <summary>
            Stores values in a IDictionary, by default this dictionary is
            placed in the current AppDomain data slot to provide data that
            is consistant across instances of DictionaryStorage when no
            dictionary is provided to the constructor.
            </summary>
        </member>
        <member name="M:Mozart.Configuration.DictionaryStorage.#ctor(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Constructs a DictionarySTorage with a specified dictionary object
            </summary>
        </member>
        <member name="M:Mozart.Configuration.DictionaryStorage.#ctor">
            <summary>
            dictionary is retrieved/placed in the current AppDomain data 
            slot to provide data that is consistant across instances of 
            DictionaryStorage.
            </summary>
        </member>
        <member name="M:Mozart.Configuration.DictionaryStorage.Read(System.String,System.String,System.String@)">
            <summary>
            returns true if the property was successfully retireved into the output
            variable 'value'
            </summary>
        </member>
        <member name="M:Mozart.Configuration.DictionaryStorage.Write(System.String,System.String,System.String)">
            <summary>
            Writes the given property by name
            </summary>
        </member>
        <member name="M:Mozart.Configuration.DictionaryStorage.Delete(System.String,System.String)">
            <summary>
            Removes a property from the storage by name
            </summary>
        </member>
        <member name="T:Mozart.Extensions.CloneExtensions">
            <summary>
            Extension methods for cloning of objects.
            </summary>
        </member>
        <member name="M:Mozart.Extensions.CloneExtensions.DeepClone``1(``0)">
            <summary>
            Produces a deep clone of the <paramref name="source"/> object. Reference integrity is maintained and
            every unique object in the graph is cloned only once.
            A current limitation of this method is that all objects in the graph must have a default constructor.
            </summary>
            <typeparam name="T">The type of the object to clone.</typeparam>
            <param name="source">The object to clone.</param>
            <returns>A deep clone of the source object.</returns>
        </member>
        <member name="M:Mozart.Extensions.CloneExtensions.DeepClone``1(``0,System.Collections.Generic.Dictionary{System.Object,System.Object})">
            <summary>
            Returns a clone of the given <paramref name="source"/> object. The <paramref name="map"/> is used as
            a cache during recursive calls to ensure that a single object is only cloned once.
            </summary>
        </member>
        <member name="M:Mozart.Extensions.CloneExtensions.CloneObject``1(``0,System.Collections.Generic.Dictionary{System.Object,System.Object})">
            <summary>
            Returns a clone of the given <paramref name="source"/> object.
            </summary>
        </member>
        <member name="M:Mozart.Extensions.CloneExtensions.CloneArray``1(``0,System.Collections.Generic.Dictionary{System.Object,System.Object})">
            <summary>
            Returns a clone of the given <paramref name="source"/> array.
            </summary>
        </member>
        <member name="M:Mozart.Extensions.CloneExtensions.CloneField(System.Reflection.FieldInfo,System.Object,System.Collections.Generic.Dictionary{System.Object,System.Object})">
            <summary>
            Determines whether the <paramref name="field"/> can be cloned or not. If the field cannot be
            cloned (because it is immutable, constant or literal) the value is returned, and otherwise
            a clone of the value will be returned (if not found in the map, a new clone is created).
            </summary>
        </member>
        <member name="M:Mozart.Extensions.CloneExtensions.ShouldClone(System.Object)">
            <summary>
            Returns true if the <paramref name="obj"/> parameter needs cloning.
            </summary>
        </member>
        <member name="M:Mozart.Extensions.CloneExtensions.IsCalculated(System.Reflection.FieldInfo,System.Type)">
            <summary>
            This method returns true for fields that we can safely exclude while cloning an object. In theory 
            this relies on knowing implementation details for types, and may thus break if the BCL changes or
            has been implemented differently. Currently only used to make dictionaries clonable.
            </summary>
        </member>
        <member name="M:Mozart.Extensions.CloneExtensions.Get(System.Reflection.MemberInfo,System.Object)">
            <summary>
            Gets the static field or property identified by <paramref name="memberInfo"/>.
            </summary>
        </member>
        <member name="M:Mozart.Extensions.CloneExtensions.Set(System.Reflection.MemberInfo,System.Object,System.Object)">
            <summary>
            Sets the static field or property identified by <paramref name="memberInfo"/> with <paramref name="value"/>.
            </summary>
        </member>
        <member name="M:Mozart.Extensions.CloneExtensions.IsFrameworkType(System.Type)">
            <summary>
            Returns true if the supplied type is defined in an assembly signed by Microsoft.
            </summary>
        </member>
        <member name="M:Mozart.Extensions.StringExtensions.ToInt32(System.String)">
            <summary>
            Convert string to int32.
            </summary>
            <param name="source">The source.</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.StringExtensions.ToInt32(System.String,System.Int32)">
            <summary>
            Convert string to int32.
            </summary>
            <param name="source">The source.</param>
            <param name="defaultValue">The default value.</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.StringExtensions.ToInt64(System.String)">
            <summary>
            Convert string to long.
            </summary>
            <param name="source">The source.</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.StringExtensions.ToInt64(System.String,System.Int64)">
            <summary>
            Convert string to long.
            </summary>
            <param name="source">The source.</param>
            <param name="defaultValue">The default value.</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.StringExtensions.ToInt16(System.String)">
            <summary>
            Convert string to short.
            </summary>
            <param name="source">The source.</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.StringExtensions.ToInt16(System.String,System.Int16)">
            <summary>
            Convert string to short.
            </summary>
            <param name="source">The source.</param>
            <param name="defaultValue">The default value.</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.StringExtensions.ToDecimal(System.String)">
            <summary>
            Convert string to decimal.
            </summary>
            <param name="source">The source.</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.StringExtensions.ToDecimal(System.String,System.Decimal)">
            <summary>
            Convert string to decimal.
            </summary>
            <param name="source">The source.</param>
            <param name="defaultValue">The default value.</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.StringExtensions.ToDateTime(System.String)">
            <summary>
            Convert string to date time.
            </summary>
            <param name="source">The source.</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.StringExtensions.ToDateTime(System.String,System.DateTime)">
            <summary>
            Convert string to date time.
            </summary>
            <param name="source">The source.</param>
            <param name="defaultValue">The default value.</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.StringExtensions.ToBoolean(System.String)">
            <summary>
            Convert string to boolean.
            </summary>
            <param name="source">The source.</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.StringExtensions.ToBoolean(System.String,System.Boolean)">
            <summary>
            Convert string tp boolean.
            </summary>
            <param name="source">The source.</param>
            <param name="defaultValue">if set to <c>true</c> [default value].</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.StringExtensions.Crop(System.String,System.String,System.String)">
            <summary>
            Returns text that is located between the startText and endText tags.
            </summary>
            <param name="sourceString">The source string.</param>
            <param name="startText">The text from which to start the crop</param>
            <param name="endText">The endpoint of the crop</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.ObjectExtensions.SafeEquals(System.Object,System.Object)">
            <summary>
            Determine if the given objects are equal, returning <see langword="true"/>
            if both are <see langword="null"/> respectively <see langword="false"/>
            if only one is <see langword="null"/>.
            </summary>
            <param name="o1">The first object to compare.</param>
            <param name="o2">The second object to compare.</param>
            <returns>
            <see langword="true"/> if the given objects are equal.
            </returns>
        </member>
        <member name="M:Mozart.Extensions.ObjectExtensions.SafeHashCode(System.Object)">
            <summary>
            Return as hash code for the given object; typically the value of
            <code>{@link Object#hashCode()}</code>. If the object is an array,
            this method will delegate to any of the <code>nullSafeHashCode</code>
            methods for arrays in this class. If the object is <code>null</code>,
            this method returns 0.
            </summary>
        </member>
        <member name="M:Mozart.Extensions.ObjectExtensions.Dump(System.Object)">
            <summary>
            Recursively prints the contents of any POCO object in a human-friendly, readable format
            </summary>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.TypeExtensions.IsOpenGeneric(System.Type)">
            <summary>
            Is this type an open generic (no type parameter specified)
            </summary>
        </member>
        <member name="M:Mozart.Extensions.TypeExtensions.IsGenericArray(System.Type)">
            <summary>
            Is this type an array of generic elements?
            </summary>
        </member>
        <member name="M:Mozart.Extensions.TypeExtensions.IsSameOrParent(System.Type,System.Type)">
            <summary>
            Determines whether the specified types are considered equal.
            </summary>
            <param name="parent">A <see cref="T:System.Type"/> instance. </param>
            <param name="child">A type possible derived from the <c>parent</c> type</param>
            <returns>True, when an object instance of the type <c>child</c>
            can be used as an object of the type <c>parent</c>; otherwise, false.</returns>
            <remarks>Note that nullable types does not have a parent-child relation to it's underlying type.
            For example, the 'int?' type (nullable int) and the 'int' type
            aren't a parent and it's child.</remarks>
        </member>
        <member name="M:Mozart.Extensions.TypeExtensions.Implements``1(System.Type)">
            <summary>
              Checks if a type implements the specified interface
            </summary>
            <typeparam name = "T">The interface type (can be generic, either specific or open)</typeparam>
            <param name = "objectType">The type to check</param>
            <returns>True if the interface is implemented by the type, otherwise false</returns>
        </member>
        <member name="M:Mozart.Extensions.TypeExtensions.Implements(System.Type,System.Type)">
            <summary>
              Checks if a type implements the specified interface
            </summary>
            <param name = "objectType">The type to check</param>
            <param name = "interfaceType">The interface type (can be generic, either specific or open)</param>
            <returns>True if the interface is implemented by the type, otherwise false</returns>
        </member>
        <member name="M:Mozart.Extensions.TypeExtensions.ImplementsGeneric(System.Type,System.Type)">
            <summary>
              Checks if a type implements an open generic at any level of the inheritance chain, including all
              base classes
            </summary>
            <param name = "objectType">The type to check</param>
            <param name = "interfaceType">The interface type (must be a generic type definition)</param>
            <returns>True if the interface is implemented by the type, otherwise false</returns>
        </member>
        <member name="M:Mozart.Extensions.TypeExtensions.ImplementsGeneric(System.Type,System.Type,System.Type@)">
            <summary>
              Checks if a type implements an open generic at any level of the inheritance chain, including all
              base classes
            </summary>
            <param name = "objectType">The type to check</param>
            <param name = "interfaceType">The interface type (must be a generic type definition)</param>
            <param name = "matchedType">The matching type that was found for the interface type</param>
            <returns>True if the interface is implemented by the type, otherwise false</returns>
        </member>
        <member name="M:Mozart.Extensions.TypeExtensions.GetFirstAttribute(System.Type,System.Type)">
            <summary>
            Retrieves a custom attribute applied to a type.
            </summary>
            <param name="type">A type instance.</param>
            <param name="attributeType">The type of attribute to search for.
            Only attributes that are assignable to this type are returned.</param>
            <returns>A reference to the first custom attribute of type <paramref name="attributeType"/>
            that is applied to element, or null if there is no such attribute.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Mozart.Extensions.TypeExtensions.GetFirstAttribute``1(System.Type)" -->
        <member name="M:Mozart.Extensions.TypeExtensions.GetConstructor(System.Type,System.Reflection.BindingFlags,System.Type[])">
            <summary>
            Gets the constructor matching the given <paramref name="bindingFlags"/> and corresponding to the 
            supplied <paramref name="parameterTypes"/> on the given <paramref name="type"/>.
            </summary>
            <param name="type">The type to reflect on.</param>
            <param name="bindingFlags">The search criteria to use when reflecting.</param>
            <param name="parameterTypes">The types of the constructor parameters in order.</param>
            <returns>The matching constructor or null if no match was found.</returns>
        </member>
        <member name="M:Mozart.Extensions.TypeExtensions.GetPropertyAny(System.Type,System.String)">
            <summary>
            Searches for the public property with the specified name.
            </summary>
            <param name="name">The String containing the name of the public property to get.</param>
            <returns>A <see cref="T:System.Reflection.PropertyInfo"/> object representing the public property with the specified name,
            if found; otherwise, a null reference.</returns>
        </member>
        <member name="M:Mozart.Extensions.TypeExtensions.GetMethod(System.Type,System.Boolean,System.String,System.Reflection.BindingFlags)">
            <summary>
            Searches for the method defined for a <see cref="T:System.Type"/>,
            using the specified name and binding flags.
            </summary>
            <param name="methodName">The String containing the name of the method to get.</param>
            <param name="generic">True to search only for a generic method, or
            False to search only for non-generic method.</param>
            <param name="type">A <see cref="T:System.Type"/> instance. </param>
            <param name="flags">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags"/> 
            that specify how the search is conducted.</param>
            <returns>A <see cref="T:System.Reflection.MethodInfo"/> object representing the method
            that matches the specified requirements, if found; otherwise, null.</returns>
        </member>
        <member name="M:Mozart.Extensions.TypeExtensions.GetMethodAny(System.Type,System.Boolean,System.String,System.Type[])">
            <summary>
            Searches for the specified instance method (public or non-public),
            using the specified name and argument types.
            </summary>
            <param name="methodName">The String containing the name of the method to get.</param>
            <param name="generic">True to search only for a generic method, or
            False to search only for non-generic method.</param>
            <param name="types">An array of <see cref="T:System.Type"/> objects representing
            the number, order, and type of the parameters for the method to get.-or-
            An empty array of the type <see cref="T:System.Type"/> (for example, <see cref="F:System.Type.EmptyTypes"/>)
            to get a method that takes no parameters.</param>
            <returns>A <see cref="T:System.Reflection.MethodInfo"/> object representing the method
            that matches the specified requirements, if found; otherwise, null.</returns>
        </member>
        <member name="M:Mozart.Extensions.TypeExtensions.GetMethodAny(System.Type,System.String,System.Type[])">
            <summary>
            Searches for the specified instance method (public or non-public),
            using the specified name and argument types.
            </summary>
            <param name="methodName">The String containing the name of the method to get.</param>
            <param name="types">An array of <see cref="T:System.Type"/> objects representing
            the number, order, and type of the parameters for the method to get.-or-
            An empty array of the type <see cref="T:System.Type"/> (for example, <see cref="F:System.Type.EmptyTypes"/>)
            to get a method that takes no parameters.</param>
            <returns>A <see cref="T:System.Reflection.MethodInfo"/> object representing the method
            that matches the specified requirements, if found; otherwise, null.</returns>
        </member>
        <member name="T:Mozart.Extensions.CollectionExtensions">
            <summary>
            The class that provides extensions for ICollection.
            </summary>
            <remarks>
            Provides extension features that ables to use ICollection data from othe data structure.
            1. Determines whether ICollection is Null or Empty.
            2. Converts as Array data type.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Mozart.Extensions.CollectionExtensions.IsNullOrEmpty``1(System.Collections.Generic.ICollection{``0})" -->
        <!-- Badly formed XML comment ignored for member "M:Mozart.Extensions.CollectionExtensions.ToArray``1(System.Collections.Generic.ICollection{``0})" -->
        <member name="M:Mozart.Extensions.DictionaryExtensions.Retrieve``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Gets the value for the specified key or adds a new value to the dictionary
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.DictionaryExtensions.Retrieve``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Gets the value for the specified key or adds a new value to the dictionary
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
            <param name="missingValue">The value to add if the key is not found</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.DictionaryExtensions.Retrieve``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})">
            <summary>
            Gets the value for the specified key or adds a new value to the dictionary
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
            <param name="valueProvider">The function to return the value to add if the key is not found</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.DictionaryExtensions.ReadFromAssembly(System.Collections.Generic.IDictionary{System.String,System.Object},System.Type,System.String)">
            <summary>
            Reads the properties from assembly (embedded resource).
            </summary>
            <param name="resourceName">The file name to read resources from.</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.DictionaryExtensions.ReadFromFile(System.Collections.Generic.IDictionary{System.String,System.Object},System.String)">
            <summary>
            Reads the properties from file system.
            </summary>
            <param name="fileName">The file name to read resources from.</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.DictionaryExtensions.RemoveLeadingWhitespace(System.String)">
            <summary>
            Strips whitespace from the front of the specified string.
            </summary>
            <param name="line">The string.</param>
            <returns>The string with all leading whitespace removed.</returns>
        </member>
        <member name="M:Mozart.Extensions.DictionaryExtensions.SplitLine(System.String)">
            <summary>
            Splits the specified string into a key / value pair.
            </summary>
            <param name="line">The line to split.</param>
            <returns>An array containing the key / value pair.</returns>
        </member>
        <member name="M:Mozart.Extensions.DictionaryExtensions.GetGroupKeys(System.Collections.Generic.IDictionary{System.String,System.Object},System.String)">
            <summary>
            Gets the property groups.
            </summary>
            <param name="prefix">The prefix.</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.DictionaryExtensions.GetGroupValues(System.Collections.Generic.IDictionary{System.String,System.Object},System.String)">
            <summary>
            Gets the property group.
            </summary>
            <param name="prefix">The prefix.</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.DictionaryExtensions.GetGroupValues(System.Collections.Generic.IDictionary{System.String,System.Object},System.String,System.Boolean)">
            <summary>
            Gets the property group.
            </summary>
            <param name="prefix">The prefix.</param>
            <param name="stripPrefix">if set to <c>true</c> [strip prefix].</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Extensions.DictionaryExtensions.GetGroupValues(System.Collections.Generic.IDictionary{System.String,System.Object},System.String,System.Boolean,System.String[])">
            <summary>
            Get all properties that start with the given prefix.  
            </summary>
            <param name="prefix">The prefix for which to search.  If it does not end in a "." then one will be added to it for search purposes.</param>
            <param name="stripPrefix">Whether to strip off the given <code>prefix</code> in the result's keys.</param>
            <param name="excludedPrefixes">Optional array of fully qualified prefixes to exclude.  For example if <code>prefix</code> is "a.b.c", then <code>excludedPrefixes</code> might be "a.b.c.ignore".</param>
            <returns>Group of <code>Properties</code> that start with the given prefix, optionally have that prefix removed, and do not include properties that start with one of the given excluded prefixes.</returns>
        </member>
        <member name="T:Mozart.Extensions.EnumerableExtensions">
            <summary>
            Some utility extensions on <see cref="T:System.Collections.Generic.IEnumerable`1"/> to supplement
            those available from Linq.
            </summary>
        </member>
        <member name="M:Mozart.Extensions.EnumerableExtensions.AreEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines if the two collections contain equal items in the same order. The two collections do not need
            to be of the same type; it is permissible to compare an array and an OrderedBag, for instance.
            </summary>
            <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
            <typeparam name="T">The type of items in the collections.</typeparam>
            <param name="c1">The first collection to compare.</param>
            <param name="c2">The second collection to compare.</param>
            <returns>True if the collections have equal items in the same order. If both collections are empty, true is returned.</returns>
        </member>
        <member name="M:Mozart.Extensions.EnumerableExtensions.AreEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines if the two collections contain equal items in the same order. The passed 
            instance of IEqualityComparer&lt;T&gt; is used for determining if two items are equal.
            </summary>
            <typeparam name="T">The type of items in the collections.</typeparam>
            <param name="c1">The first collection to compare.</param>
            <param name="c2">The second collection to compare.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals member function of this interface is called.</param>
            <returns>True if the collections have equal items in the same order. If both collections are empty, true is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="c1"/>, <paramref name="c2"/>, or
            <paramref name="equalityComparer"/> is null.</exception>
        </member>
        <member name="M:Mozart.Extensions.EnumerableExtensions.AreEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
            <summary>
            Determines if the two collections contain "equal" items in the same order. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
            <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being tested
            for need not be equality. For example, the following code determines if each integer in
            list1 is less than or equal to the corresponding integer in list2.
            <code>
            List&lt;int&gt; list1, list2;
            if (EqualCollections(list1, list2, delegate(int x, int y) { return x &lt;= y; }) {
                // the check is true...
            }
            </code>
            </remarks>
            <typeparam name="T">The type of items in the collections.</typeparam>
            <param name="c1">The first collection to compare.</param>
            <param name="c2">The second collection to compare.</param>
            <param name="predicate">The BinaryPredicate used to compare items for "equality". 
            This predicate can compute any relation between two items; it need not represent equality or an equivalence relation.</param>
            <returns>True if <paramref name="predicate"/>returns true for each corresponding pair of
            items in the two collections. If both collections are empty, true is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="c1"/>, <paramref name="c2"/>, or
            <paramref name="predicate"/> is null.</exception>
        </member>
        <member name="M:Mozart.Extensions.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Execute <paramref name="action"/> for each element of <paramref name="sequence"/>.
            </summary>
            <typeparam name="T">Type of items in <paramref name="sequence"/>.</typeparam>
            <param name="sequence">Sequence of items to act on.</param>
            <param name="action">Action to invoke for each item.</param>
        </member>
        <member name="M:Mozart.Extensions.EnumerableExtensions.Visit``1(System.Collections.IEnumerable,System.Func{``0,System.Boolean})">
            <summary>
            Enumerates a collection, calling the callback until false is returned
            </summary>
            <typeparam name="T">The type of item being enumerated</typeparam>
            <param name="collection">The collection to enumerate</param>
            <param name="callback">The callback to call for each element</param>
            <returns>True if all of the elements were enumerated, otherwise false</returns>  
        </member>
        <member name="M:Mozart.Extensions.EnumerableExtensions.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
            <summary>
            Given a sequence, combine it with another sequence, passing the corresponding
            elements of each sequence to the <paramref name="zipper"/> action to create
            a new single value from the two sequence elements. "Zip" here refers to a zipper,
            not the compression algorithm. The resulting sequence will have the same number
            of elements as the shorter of sequence1 and sequence2.
            </summary>
            <typeparam name="T1">Type of the elements in the first sequence.</typeparam>
            <typeparam name="T2">Type of the elements in the second sequence.</typeparam>
            <typeparam name="TResult">Type of the resulting sequence elements.</typeparam>
            <param name="sequence1">The first sequence to combine.</param>
            <param name="sequence2">The second sequence to combine.</param>
            <param name="zipper">Func used to calculate the resulting values.</param>
            <returns>The result sequence.</returns>
        </member>
        <member name="M:Mozart.Extensions.EnumerableExtensions.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Take two sequences and return a new sequence of <see cref="T:System.Collections.Generic.KeyValuePair`2"/> objects.
            </summary>
            <typeparam name="T1">Type of objects in sequence1.</typeparam>
            <typeparam name="T2">Type of objects in sequence2.</typeparam>
            <param name="sequence1">First sequence.</param>
            <param name="sequence2">Second sequence.</param>
            <returns>The sequence of <see cref="T:System.Collections.Generic.KeyValuePair`2"/> objects.</returns>
        </member>
        <member name="M:Mozart.Extensions.EnumerableExtensions.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Take two sequences and return a <see cref="T:System.Collections.Generic.IDictionary`2"/> with the first sequence
            holding the keys and the corresponding elements of the second sequence containing the values.
            </summary>
            <typeparam name="TKey">Type of keys in the dictionary.</typeparam>
            <typeparam name="TValue">Type of values in the dictionary.</typeparam>
            <param name="keys">Sequence of dictionary keys.</param>
            <param name="values">Sequence of dictionary values.</param>
            <returns>The constructed dictionary.</returns>
        </member>
        <member name="M:Mozart.Extensions.EnumerableExtensions.Print(System.Collections.IEnumerable)">
            <summary>
            Gets a string representation of the elements in the collection.
            The string representation starts with "{", has a list of items separated
            by commas (","), and ends with "}". Each item in the collection is 
            converted to a string by calling its ToString method (null is represented by "null").
            Contained collections (except strings) are recursively converted to strings by this method.
            </summary>
            <param name="collection">A collection to get the string representation of.</param>
            <returns>The string representation of the collection. If <paramref name="collection"/> is null, then the string "null" is returned.</returns>
        </member>
        <member name="M:Mozart.Extensions.EnumerableExtensions.Print(System.Collections.IEnumerable,System.Boolean,System.String,System.String,System.String)">
            <summary>
            Gets a string representation of the elements in the collection.
            The string to used at the beginning and end, and to separate items,
            and supplied by parameters. Each item in the collection is 
            converted to a string by calling its ToString method (null is represented by "null").
            </summary>
            <param name="collection">A collection to get the string representation of.</param>
            <param name="recursive">If true, contained collections (except strings) are converted to strings by a recursive call to this method, instead
            of by calling ToString.</param>
            <param name="start">The string to appear at the beginning of the output string.</param>
            <param name="separator">The string to appear between each item in the string.</param>
            <param name="end">The string to appear at the end of the output string.</param>
            <returns>The string representation of the collection. If <paramref name="collection"/> is null, then the string "null" is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="start"/>, <paramref name="separator"/>, or <paramref name="end"/>
             is null.</exception>
        </member>
        <member name="M:Mozart.Extensions.EnumerableExtensions.Print``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Gets a string representation of the mappings in a dictionary.
            The string representation starts with "{", has a list of mappings separated
            by commas (", "), and ends with "}". Each mapping is represented
            by "key->value". Each key and value in the dictionary is 
            converted to a string by calling its ToString method (null is represented by "null").
            Contained collections (except strings) are recursively converted to strings by this method.
            </summary>
            <param name="dictionary">A dictionary to get the string representation of.</param>
            <returns>The string representation of the collection, or "null" 
            if <paramref name="dictionary"/> is null.</returns>
        </member>
        <member name="M:Mozart.Extensions.ArrayExtensions.GetHashCode(System.Array)">
            <summary>
            Returns hash code for an array that is generated based on the elements.
            </summary>
            <remarks>
            Hash code returned by this method is guaranteed to be the same for
            arrays with equal elements.
            </remarks>
            <param name="array">
            Array to calculate hash code for.
            </param>
            <returns>
            A hash code for the specified array.
            </returns>
        </member>
        <member name="M:Mozart.Extensions.ArrayExtensions.Range``1(``0[],System.Int32,System.Int32)">
            <summary>
            Returns a view onto a sub-range of an array. Items from <paramref name="array"/> are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to <paramref name="array"/>
            are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the 
            view. After an insertion, the last item in <paramref name="array"/> "falls off the end". After a deletion, the
            last item in array becomes the default value (0 or null).
            </summary>
            <remarks>This method can be used to apply an algorithm to a portion of a array. For example:
            <code>Algorithms.ReverseInPlace(Algorithms.Range(array, 3, 6))</code>
            will reverse the 6 items beginning at index 3.</remarks>
            <param name="array">The array to view.</param>
            <param name="start">The starting index of the view.</param>
            <param name="count">The number of items in the view.</param>
            <returns>A list that is a view onto the given sub-array. </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> or <paramref name="count"/> is negative.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> + <paramref name="count"/> is greater than the
            size of <paramref name="array"/>.</exception>
        </member>
        <member name="M:Mozart.Extensions.ListExtensions.QuickSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts a list or array in place. A supplied IComparer&lt;T&gt; is used
            to compare the items in the list. 
            </summary>
            <remarks><para>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</para>
            <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</para></remarks>
            <param name="list">The list or array to sort.</param>
            <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
        </member>
        <member name="M:Mozart.Extensions.ListExtensions.Convert``2(System.Collections.Generic.IEnumerable{``0},System.Converter{``0,``1})">
            <summary>
            Convert a collection of items by applying a delegate to each item in the collection. The resulting collection
            contains the result of applying <paramref name="converter"/> to each item in <paramref name="sourceCollection"/>, in
            order.
            </summary>
            <typeparam name="TSource">The type of items in the collection to convert.</typeparam>
            <typeparam name="TDest">The type each item is being converted to.</typeparam>
            <param name="sourceCollection">The collection of item being converted.</param>
            <param name="converter">A delegate to the method to call, passing each item in <paramref name="sourceCollection"/>.</param>
            <returns>The resulting collection from applying <paramref name="converter"/> to each item in <paramref name="sourceCollection"/>, in
            order.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sourceCollection"/> or <paramref name="converter"/> is null.</exception>
        </member>
        <member name="M:Mozart.Extensions.ListExtensions.AsReverse``1(System.Collections.Generic.IList{``0})">
            <summary>
            Reverses a list and returns the reversed list, without changing the source list.
            </summary>
            <param name="source">The list to reverse.</param>
            <returns>A collection that contains the items from <paramref name="source"/> in reverse order.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
        </member>
        <member name="M:Mozart.Extensions.ListExtensions.Reverse``1(System.Collections.Generic.IList{``0})">
            <summary>
            Reverses a list or array in place.
            </summary>
            <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</remarks>
            <param name="list">The list or array to reverse.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="list"/> is read only.</exception>
        </member>
        <member name="M:Mozart.Extensions.ListExtensions.LastIndexOf``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Finds the index of the last item in a list equal to a given item.
            </summary>
            <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
            <param name="list">The list to search.</param>
            <param name="item">The item to search for.</param>
            <returns>The index of the last item equal to <paramref name="item"/>. -1 if no such item exists in the list.</returns>
        </member>
        <member name="M:Mozart.Extensions.ListExtensions.LastIndexOf``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Finds the index of the last item in a list equal to a given item. A passed
            IEqualityComparer is used to determine equality.
            </summary>
            <param name="list">The list to search.</param>
            <param name="item">The item to search for.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
            <returns>The index of the last item equal to <paramref name="item"/>. -1 if no such item exists in the list.</returns>
        </member>
        <member name="M:Mozart.Extensions.ListExtensions.Range``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Returns a view onto a sub-range of a list. Items from <paramref name="list"/> are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to <paramref name="list"/>
            are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the 
            view, but insertions and deletions in the underlying list do not.
            </summary>
            <remarks>This method can be used to apply an algorithm to a portion of a list. For example:
            <code>Algorithms.ReverseInPlace(Algorithms.Range(list, 3, 6))</code>
            will reverse the 6 items beginning at index 3.</remarks>
            <typeparam name="T">The type of the items in the list.</typeparam>
            <param name="list">The list to view.</param>
            <param name="start">The starting index of the view.</param>
            <param name="count">The number of items in the view.</param>
            <returns>A list that is a view onto the given sub-list. </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> or <paramref name="count"/> is negative.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> + <paramref name="count"/> is greater than the
            size of <paramref name="list"/>.</exception>
        </member>
        <member name="M:Mozart.Extensions.ByteArrayExtensions.CompareTo(System.Byte[],System.Byte[])">
            <summary> Compares the contents of the byte arrays and returns the result. </summary>
        </member>
        <member name="M:Mozart.Extensions.ByteArrayExtensions.ComputeHashCode(System.Byte[])">
            <summary> Returns a hash code the instance of the object </summary>
        </member>
        <member name="M:Mozart.Extensions.ByteArrayExtensions.Combine(System.Byte[],System.Byte[])">
            <summary>
            <para>Combines two byte arrays into one.</para>
            </summary>
            <param name="buffer1"><para>The prefixed bytes.</para></param>
            <param name="buffer2"><para>The suffixed bytes.</para></param>
            <returns><para>The combined byte arrays.</para></returns>
        </member>
        <member name="T:Mozart.Extensions.DateTimeExtensions">
            <summary>
            The class that provides DateTime extension features. 
            </summary>
            <remarks>
            Provides features to converd DateTimt to as following formats:
            1. Convtert DateTime to UniversalTime.
            2. Convtert DateTime to second/milliseconds.
            3. Convert DateTime as a specific string format.
            </remarks>
        </member>
        <member name="M:Mozart.Extensions.DateTimeExtensions.ToStableUniversalTime(System.DateTime)">
            <summary>
            Converts target time as UniversalTime.
            </summary>
            <param name="dateTime">Target time to convert.</param>
            <returns>
            Return the converted UniversalTime.
            If the target time is already UniversalTime type, there is no returns.
            </returns>
        </member>
        <member name="M:Mozart.Extensions.DateTimeExtensions.RoundToMs(System.DateTime)">
            <summary>
            Converts target time in milliseconds.
            </summary>
            <param name="dateTime">Target time.</param>
            <returns>
            Returns the converted time.
            </returns>
        </member>
        <member name="M:Mozart.Extensions.DateTimeExtensions.RoundToSecond(System.DateTime)">
            <summary>
            Converts target time in seconds.
            </summary>
            <param name="dateTime">Target time.</param>
            <returns>
            Returns the converted time.
            </returns>
        </member>
        <member name="M:Mozart.Extensions.DateTimeExtensions.IsEqualToTheSecond(System.DateTime,System.DateTime)">
            <summary>
            Converts the time into seconds, compares the two times and returns the comparison results.
            </summary>
            <param name="dateTime">Target time.</param>
            <param name="otherDateTime">Target time used for comparison.</param>
            <returns>
            Returns the comparison results.
            </returns>
        </member>
        <member name="M:Mozart.Extensions.DateTimeExtensions.FmtSortableDate(System.DateTime)">
            <summary>
            Convert target time as "yyyy-MM-dd" format.
            </summary>
            <param name="date">Target time.</param>
            <returns>
            Return converted time.
            </returns>
        </member>
        <member name="M:Mozart.Extensions.DateTimeExtensions.FmtSortableDateTime(System.DateTime)">
            <summary>
            Convert target time as "yyyy-MM-dd HH:mm:ss" format.
            </summary>
            <param name="dateTime">Target time.</param>
            <returns>
            Return converted time.
            </returns>
        </member>
        <member name="M:Mozart.Extensions.EnumExtensions.ToEnum``1(System.Object,``0)">
            <summary>hidden</summary>
        </member>
        <member name="M:Mozart.Extensions.EnumExtensions.ToEnum``1(System.Object,``0,System.Boolean)">
            <summary>hidden</summary>
        </member>
        <member name="M:Mozart.Extensions.EnumExtensions.IsDefined(System.Type,System.String)">
            <summary>hidden</summary>
        </member>
        <member name="M:Mozart.Extensions.StreamExtensions.ReadAllBytes(System.IO.Stream)">
            <summary> Reads all of the bytes from the input stream, input stream will be disposed </summary>
        </member>
        <member name="M:Mozart.Extensions.StreamExtensions.Read(System.IO.Stream,System.Byte[])">
            <summary> Reads a the number of bytes specified or throws IOException </summary>
        </member>
        <member name="M:Mozart.Extensions.StreamExtensions.Read(System.IO.Stream,System.Int32)">
            <summary> Reads a the number of bytes specified or throws IOException </summary>
        </member>
        <member name="M:Mozart.Extensions.StreamExtensions.Read(System.IO.Stream,System.Byte[],System.Int32)">
            <summary> Reads a the number of bytes specified or throws IOException </summary>
        </member>
        <member name="M:Mozart.Extensions.StreamExtensions.ReadChunk(System.IO.Stream,System.Byte[],System.Int32)">
            <summary> Attempts to read the number of bytes specified and returns the actual count </summary>
        </member>
        <member name="M:Mozart.Extensions.StreamExtensions.ReadChunk(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary> Attempts to read the number of bytes specified and returns the actual count </summary>
        </member>
        <member name="M:Mozart.Reflection.GenericTypeExtensions.GetClosedParameterType(System.Type,System.Type[])">
            <summary>
            If this type is an open generic, use the
            given <paramref name="genericArguments"/> array to
            determine what the required closed type is and return that.
            </summary>
            <remarks>If the parameter is not an open type, just
            return this parameter's type.</remarks>
            <param name="genericArguments">Type arguments to substitute in for
            the open type parameters.</param>
            <returns>Corresponding closed type of this parameter.</returns>
        </member>
        <member name="T:Mozart.Threading.CountdownLatch">
            <summary>
            Allows a master thread to wait for a set of
            subservient threads to complete work.
            </summary>
        </member>
        <member name="T:Mozart.Threading.AsyncExecutor">
            <summary>
            Attempts to provide a method of running asynchronous methods (the BeginXXX/EndXXX style)
            in a linear manner avoiding all the propogation of those methods up the call stack
            
            Slightly influence by Jeffrey Richter's PowerThreading library
            https://github.com/Wintellect/PowerThreading
            
            </summary>
        </member>
        <member name="M:Mozart.Threading.IAsyncExecutor.Execute(System.Collections.Generic.IEnumerator{System.Int32})">
            <summary>
            Executes a method containing yields, but waits for said method to complete
            </summary>
            <param name="enumerator">The method to execute</param>
        </member>
        <member name="M:Mozart.Threading.IAsyncExecutor.BeginExecute(System.Collections.Generic.IEnumerator{System.Int32},System.AsyncCallback,System.Object)">
            <summary>
            Asynchronously executes a method containing yields
            </summary>
            <param name="enumerator">The method to execute</param>
            <param name="callback">The asynchronous method to call back</param>
            <param name="state">A state object passed to the asynchronous callback</param>
            <returns></returns>
        </member>
        <member name="M:Mozart.Threading.IAsyncExecutor.EndExecute(System.IAsyncResult)">
            <summary>
            Completes the execution of an asynchronous methods
            </summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:Mozart.Threading.IAsyncExecutor.Cancel">
            <summary>
            Cancel the execution of an asynchronous method
            </summary>
        </member>
        <member name="M:Mozart.Threading.IAsyncExecutor.End">
            <summary>
            Returns a callback for the BeginXXX method being yielded
            </summary>
            <returns></returns>
        </member>
        <member name="M:Mozart.Threading.IAsyncExecutor.Result">
            <summary>
            Returns the next async result in the queue of completed asynchronous methods
            </summary>
            <returns></returns>
        </member>
        <member name="T:Mozart.Threading.CancellableMethod">
            <summary>
            Delegate that defines a cancellable method.
            </summary>
            <param name="cancellationToken">CancellationToken to cancel the process.</param>
        </member>
        <member name="T:Mozart.Threading.CancellableMethodExecutor">
            <summary>
            Executes a cancellable method in a dedicated thread.
            </summary>
        </member>
        <member name="F:Mozart.Threading.CancellableMethodExecutor.cancellationTokenSource">
            <summary>
            CancellationTokenSource use to cancel the CancellableMethod.
            </summary>
        </member>
        <member name="F:Mozart.Threading.CancellableMethodExecutor.cancellableMethodDoneEvent">
            <summary>
            AutoResetEvent that is part of the mechanism for stopping the process.
            </summary>
        </member>
        <member name="F:Mozart.Threading.CancellableMethodExecutor.cancellableMethod">
            <summary>
            CancellableMethod that is executed.
            </summary>
        </member>
        <member name="F:Mozart.Threading.CancellableMethodExecutor.sync">
            <summary>
            Synchronization object.
            </summary>
        </member>
        <member name="M:Mozart.Threading.CancellableMethodExecutor.#ctor(Mozart.Threading.CancellableMethod,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Mozart.Threading.CancellableMethodExecutor" /> class.
            </summary>
            <param name="cancellableMethod">A CancellableMethod.</param>
            <param name="processName">A process name.</param>
        </member>
        <member name="E:Mozart.Threading.CancellableMethodExecutor.CancellableMethodMenagerEvent">
            <summary>
            A general event
            </summary>
        </member>
        <member name="E:Mozart.Threading.CancellableMethodExecutor.BeforeStart">
            <summary>
            Event raised before the CancellableMethod starts. 
            Do not update the UI from this event since the UI thread is going to be waiting for the method Start() to return.
            </summary>
        </member>
        <member name="E:Mozart.Threading.CancellableMethodExecutor.BeforeStop">
            <summary>
            Event raised before the CancellableMethod stops.
            Do not update the UI from this event since the UI thread is going to be waiting for the method Stop() to return.
            </summary>
        </member>
        <member name="E:Mozart.Threading.CancellableMethodExecutor.ProcessStarted">
            <summary>
            Event raised after the CancellableMethod starts.
            </summary>
        </member>
        <member name="E:Mozart.Threading.CancellableMethodExecutor.ProcessStopped">
            <summary>
            Event raised after the CancellableMethod stops.
            </summary>
        </member>
        <member name="P:Mozart.Threading.CancellableMethodExecutor.ProcessName">
            <summary>
            Gets the name of the cancellable process.
            </summary>
        </member>
        <member name="P:Mozart.Threading.CancellableMethodExecutor.Running">
            <summary>
            Gets a value indicating whether the CancellableMethod is running.
            </summary>
        </member>
        <member name="M:Mozart.Threading.CancellableMethodExecutor.Start">
            <summary>
            Starts the CancellableMethod in a dedicated thread.
            </summary>
        </member>
        <member name="M:Mozart.Threading.CancellableMethodExecutor.Stop(System.Int32)">
            <summary>
            Stops the CancellableMethod.
            </summary>
            <param name="timeout">The timeout in milliseconds.</param>
        </member>
        <member name="M:Mozart.Threading.CancellableMethodExecutor.OnCancellableProcessEvent(Mozart.Threading.CancellableMethodManagerEventArgs)">
            <summary>
            Raises a general event when assigned.
            </summary>
            <param name="e">A CancellableMethodManagerEventArgs.</param>
        </member>
        <member name="M:Mozart.Threading.CancellableMethodExecutor.OnBeforeStart(System.EventArgs)">
            <summary>
            Raises a before start event when assigned.
            </summary>
            <param name="e">A EventArgs.</param>
        </member>
        <member name="M:Mozart.Threading.CancellableMethodExecutor.OnBeforeStop(System.EventArgs)">
            <summary>
            Raises a before stop event when assigned.
            </summary>
            <param name="e">A EventArgs.</param>
        </member>
        <member name="M:Mozart.Threading.CancellableMethodExecutor.OnProcessStarted(System.EventArgs)">
            <summary>
            Raises a process started event when assigned.
            </summary>
            <param name="e">A EventArgs.</param>
        </member>
        <member name="M:Mozart.Threading.CancellableMethodExecutor.OnProcessStopped(System.EventArgs)">
            <summary>
            Raises a process stopped event when assigned.
            </summary>
            <param name="e">A EventArgs.</param>
        </member>
        <member name="M:Mozart.Threading.CancellableMethodExecutor.ExecuteCancellableMethod">
            <summary>
            Executes the CancellableMethod.
            </summary>
        </member>
        <member name="T:Mozart.Threading.CancellableMethodManagerEventArgs">
            <summary>
            Event arguments used for events in CancellableMethodManager.
            </summary>
        </member>
        <member name="M:Mozart.Threading.CancellableMethodManagerEventArgs.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Mozart.Threading.CancellableMethodManagerEventArgs" /> class.
            </summary>
            <param name="message">A Message.</param>
            <param name="exception">An Exception.</param>
        </member>
        <member name="P:Mozart.Threading.CancellableMethodManagerEventArgs.Message">
            <summary>
            Gets the description of the event.
            </summary>
        </member>
        <member name="P:Mozart.Threading.CancellableMethodManagerEventArgs.Exception">
            <summary>
            Gets the exception that is part of the event information.
            </summary>
        </member>
        <member name="T:Mozart.Threading.ReaderWriterLock`1">
            <summary>
            Interface to a ReaderWriterLock of type T
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Mozart.Threading.ReaderWriterLockExtensions">
            <summary>
            Adds methods to use ReaderWriterLockSlim easily,
            always with time-outs to avoid dead-locks.
            </summary>
        </member>
        <member name="M:Mozart.Threading.ReaderWriterLockExtensions.ReadLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Acquires a read-lock using the default time-out.
            </summary>
        </member>
        <member name="M:Mozart.Threading.ReaderWriterLockExtensions.ReadLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)">
            <summary>
            Acquires a read-lock, using the given time-out.
            </summary>
        </member>
        <member name="M:Mozart.Threading.ReaderWriterLockExtensions.TryReadLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Tries to acquire a read-lock on the given object using the default timeout. 
            If it fails, returns null.
            </summary>
            <param name="lockObject">The object to lock.</param>
            <returns>A disposable object to release the lock, or null.</returns>
        </member>
        <member name="M:Mozart.Threading.ReaderWriterLockExtensions.TryReadLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)">
            <summary>
            Tries to acquire a read-lock on the given object using the specified timeout. 
            If it fails, returns null.
            </summary>
            <param name="lockObject">The object to lock.</param>
            <param name="timeout">The timeout to try for the lock.</param>
            <returns>A disposable object to release the lock, or null.</returns>
        </member>
        <member name="M:Mozart.Threading.ReaderWriterLockExtensions.UpgradeableLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Acquires an upgradeable-lock using the default time-out.
            </summary>
        </member>
        <member name="M:Mozart.Threading.ReaderWriterLockExtensions.UpgradeableLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)">
            <summary>
            Acquires an upgradeable-lock, using the given time-out.
            </summary>
        </member>
        <member name="M:Mozart.Threading.ReaderWriterLockExtensions.TryUpgradeableLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Tries to acquire an upgradeable lock on the given object, using the default timeout.
            If it fails, returns null.
            </summary>
            <param name="lockObject">The object to try to lock.</param>
            <returns>An disposable object to release the lock, or null if the locks fails.</returns>
        </member>
        <member name="M:Mozart.Threading.ReaderWriterLockExtensions.TryUpgradeableLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)">
            <summary>
            Tries to acquire an upgradeable lock on the given object, using the specified timeout.
            If it fails, returns null.
            </summary>
            <param name="lockObject">The object to try to lock.</param>
            <param name="timeout">The maximum time to wait for the lock.</param>
            <returns>An disposable object to release the lock, or null if the locks fails.</returns>
        </member>
        <member name="M:Mozart.Threading.ReaderWriterLockExtensions.WriteLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Acquires a write-lock using the default time-out.
            </summary>
        </member>
        <member name="M:Mozart.Threading.ReaderWriterLockExtensions.WriteLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)">
            <summary>
            Acquires a write-lock, using the given time-out.
            </summary>
        </member>
        <member name="M:Mozart.Threading.ReaderWriterLockExtensions.TryWriteLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Tries to acquire a write-lock on the given object using the default timeout.
            If it fails, returns null.
            </summary>
            <param name="lockObject">The object to lock.</param>
            <returns>A disposable object to release the lock, or null.</returns>
        </member>
        <member name="M:Mozart.Threading.ReaderWriterLockExtensions.TryWriteLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)">
            <summary>
            Tries to acquire a write-lock on the given object using the specified timeout.
            If it fails, returns null.
            </summary>
            <param name="lockObject">The object to lock.</param>
            <param name="timeout">The maximum time to wait for the lock.</param>
            <returns>A disposable object to release the lock, or null.</returns>
        </member>
        <member name="T:Mozart.Processes.ArgumentList">
            <summary>
            This is a private class as the means of sharing is to simply include the source file not
            reference a library.
            </summary>
        </member>
        <member name="M:Mozart.Processes.ArgumentList.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the ArgumentList class using the argument list provided
            </summary>
        </member>
        <member name="M:Mozart.Processes.ArgumentList.#ctor(System.StringComparer,System.String[])">
            <summary>
            Initializes a new instance of the ArgumentList class using the argument list provided
            and using the string comparer provided, by default this is case-insensitive
            </summary>
        </member>
        <member name="P:Mozart.Processes.ArgumentList.Unnamed">
            <summary>
            Returns a list of arguments that did not start with a character in the PrefixChars
            static collection.  These arguments can be modified by the methods on the returned
            collection, or you set this property to a new collection (a copy is made).
            </summary>
        </member>
        <member name="M:Mozart.Processes.ArgumentList.AddRange(System.String[])">
            <summary>
            Parses the strings provided for switch names and optionally values, by default in one
            of the following forms: "/name=value", "/name:value", "-name=value", "-name:value"
            </summary>
        </member>
        <member name="M:Mozart.Processes.ArgumentList.Add(System.String,System.String)">
            <summary>
            Adds a name/value pair to the collection of arguments, if value is null the name is
            added with no values.
            </summary>
        </member>
        <member name="P:Mozart.Processes.ArgumentList.Keys">
            <summary>
            A string collection of all keys in the arguments
            </summary>
        </member>
        <member name="M:Mozart.Processes.ArgumentList.TryGetValue(System.String,Mozart.Processes.ArgumentList.Item@)">
            <summary>
            Returns true if the value was found by that name and set the output value
            </summary>
        </member>
        <member name="M:Mozart.Processes.ArgumentList.TryGetValue(System.String,System.String@)">
            <summary>
            Returns true if the value was found by that name and set the output value
            </summary>
        </member>
        <member name="M:Mozart.Processes.ArgumentList.SafeGet(System.String)">
            <summary>
            Returns an Item of name even if it does not exist
            </summary>
        </member>
        <member name="M:Mozart.Processes.ArgumentList.GetKeyForItem(Mozart.Processes.ArgumentList.Item)">
            <summary>
            Abract override for extracting key
            </summary>
        </member>
        <member name="T:Mozart.Processes.ArgumentList.Item">
            <summary>
            This is a single named argument within an argument list collection, this
            can be implicitly assigned to a string, or a string[] array
            </summary>
        </member>
        <member name="M:Mozart.Processes.ArgumentList.Item.#ctor(System.String,System.String[])">
            <summary>
            Constructs an item for the name and values provided.
            </summary>
        </member>
        <member name="P:Mozart.Processes.ArgumentList.Item.Name">
            <summary>
            Returns the name of this item
            </summary>
        </member>
        <member name="P:Mozart.Processes.ArgumentList.Item.Value">
            <summary>
            Returns the first value of this named item or null if one doesn't exist
            </summary>
        </member>
        <member name="P:Mozart.Processes.ArgumentList.Item.Values">
            <summary>
            Returns the collection of items in this named slot
            </summary>
        </member>
        <member name="M:Mozart.Processes.ArgumentList.Item.ToArray">
            <summary>
            Same as the .Values property, returns the collection of items in this named slot
            </summary>
            <returns></returns>
        </member>
        <member name="M:Mozart.Processes.ArgumentList.Item.AddRange(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Add one or more values to this named item
            </summary>
        </member>
        <member name="M:Mozart.Processes.ArgumentList.Item.op_Implicit(Mozart.Processes.ArgumentList.Item)~System.Collections.Generic.KeyValuePair{System.String,System.String[]}">
            <summary>
            Converts this item to key-value pair to rem to a dictionary
            </summary>
        </member>
        <member name="M:Mozart.Processes.ArgumentList.Item.op_Implicit(Mozart.Processes.ArgumentList.Item)~System.String">
            <summary>
            Converts this item to a string by getting the first value or null if none
            </summary>
        </member>
        <member name="M:Mozart.Processes.ArgumentList.Item.op_Implicit(Mozart.Processes.ArgumentList.Item)~System.String[]">
            <summary>
            Converts this item to array of strings
            </summary>
        </member>
        <member name="M:Mozart.Processes.ArgumentUtility.Parse(System.String)">
            <summary> Parses the individual arguments from the given input string. </summary>
        </member>
        <member name="M:Mozart.Processes.ArgumentUtility.Join(System.String[])">
            <summary> The inverse of Parse, joins the arguments together and properly escapes output </summary>
        </member>
        <member name="P:Mozart.Processes.ArgumentUtility.PrefixChars">
            <summary>
            Controls the allowable prefix characters that will preceed named arguments
            </summary>
        </member>
        <member name="P:Mozart.Processes.ArgumentUtility.NameDelimeters">
            <summary>
            Controls the allowable delimeter characters seperate argument names from values
            </summary>
        </member>
        <member name="M:Mozart.Processes.ArgumentUtility.TryParseNameValue(System.String,System.String@,System.String@)">
            <summary>
            Attempts to parse a name value pair from '/name=value' format
            </summary>
        </member>
        <member name="M:Mozart.Processes.ArgumentUtility.Remove(System.String[]@,System.String,System.String@)">
            <summary>
            Searches the arguments until it finds a switch or value by the name in find and
            if found it will:
            A) Remove the item from the arguments
            B) Set the out parameter value to any value found, or null if just '/name'
            C) Returns true that it was found and removed.
            </summary>
        </member>
        <member name="T:Mozart.Processes.AssemblyRunner">
            <summary>
            Create an AppDomain configured to run the .Net Assembly provided and marshalls Console input/output to and
            from the app domain when run.  This allow a more performant execution of .Net command-line tools while
            keeping with *most* of the behavior of running out-of-process.  Some serious side effects can occur when
            using Environment.* settings like CurrentDirectory and ExitCode since these are shared with the appdomain.
            </summary>
        </member>
        <member name="M:Mozart.Processes.AssemblyRunner.#ctor(System.String)">
            <summary>
            Constructs the AppDomain for the given executable by using it's path for the base directory and configuraiton file.
            </summary>
        </member>
        <member name="M:Mozart.Processes.AssemblyRunner.Finalize">
            <summary>
            Ensures clean-up of the app domain... This has to be pushed off of the GC Cleanup thread as AppDoamin.Unload will
            fail on GC thread.
            </summary>
        </member>
        <member name="M:Mozart.Processes.AssemblyRunner.UnloadDomain(System.AppDomain)">
            <summary> Ignores errors from the AppDomain.Unload since exceptions would be unhandled. </summary>
        </member>
        <member name="P:Mozart.Processes.AssemblyRunner.IsDisposed">
            <summary>
            Returns true if this object's worker domain has been unloaded.
            </summary>
        </member>
        <member name="M:Mozart.Processes.AssemblyRunner.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Mozart.Processes.AssemblyRunner.ToString">
            <summary> Returns a debug-view string of process/arguments to execute </summary>
        </member>
        <member name="E:Mozart.Processes.AssemblyRunner.OutputReceived">
            <summary> Notifies caller of writes to the std::err or std::out </summary>
        </member>
        <member name="E:Mozart.Processes.AssemblyRunner.ProcessExited">
            <summary> Notifies caller when the process exits </summary>
        </member>
        <member name="P:Mozart.Processes.AssemblyRunner.WorkingDirectory">
            <summary> Gets or sets the initial working directory for the process. </summary>
        </member>
        <member name="P:Mozart.Processes.AssemblyRunner.ExitCode">
            <summary> Waits for the process to exit and returns the exit code </summary>
        </member>
        <member name="P:Mozart.Processes.AssemblyRunner.IsRunning">
            <summary> Returns true if this instance is running a process </summary>
        </member>
        <member name="M:Mozart.Processes.AssemblyRunner.Kill">
            <summary> Kills the process if it is still running </summary>
        </member>
        <member name="M:Mozart.Processes.AssemblyRunner.WaitForExit">
            <summary> Closes std::in and waits for the process to exit </summary>
        </member>
        <member name="M:Mozart.Processes.AssemblyRunner.WaitForExit(System.TimeSpan)">
            <summary> Closes std::in and waits for the process to exit, returns false if the process did not exit in the time given </summary>
        </member>
        <member name="M:Mozart.Processes.AssemblyRunner.WaitForExit(System.TimeSpan,System.Boolean)">
            <summary> Waits for the process to exit, returns false if the process did not exit in the time given </summary>
        </member>
        <member name="M:Mozart.Processes.AssemblyRunner.Run">
            <summary> Runs the process and returns the exit code. </summary>
        </member>
        <member name="M:Mozart.Processes.AssemblyRunner.Run(System.String[])">
            <summary> Runs the process with additional arguments and returns the exit code. </summary>
        </member>
        <member name="M:Mozart.Processes.AssemblyRunner.Run(System.IO.TextReader,System.String[])">
            <summary> Runs the process with additional arguments and returns the exit code. </summary>
        </member>
        <member name="M:Mozart.Processes.AssemblyRunner.Start">
            <summary> Starts the process and returns. </summary>
        </member>
        <member name="M:Mozart.Processes.AssemblyRunner.Start(System.String[])">
            <summary> Starts the process with additional arguments and returns. </summary>
        </member>
        <member name="M:Mozart.Processes.AssemblyRunner.Start(System.IO.TextReader,System.String[])">
            <summary> Starts the process with additional arguments and returns. </summary>
        </member>
        <member name="T:Mozart.Processes.IProcessRunner">
            <summary>
            The common interface between spawning processes, and spawning scripts.
            </summary>
        </member>
        <member name="E:Mozart.Processes.IProcessRunner.OutputReceived">
            <summary> Notifies caller of writes to the std::err or std::out </summary>
        </member>
        <member name="E:Mozart.Processes.IProcessRunner.ProcessExited">
            <summary> Notifies caller when the process exits </summary>
        </member>
        <member name="P:Mozart.Processes.IProcessRunner.StandardInput">
            <summary> Allows writes to the std::in for the process </summary>
        </member>
        <member name="P:Mozart.Processes.IProcessRunner.ExitCode">
            <summary> Waits for the process to exit and returns the exit code </summary>
        </member>
        <member name="P:Mozart.Processes.IProcessRunner.IsRunning">
            <summary> Returns true if this instance is running a process </summary>
        </member>
        <member name="M:Mozart.Processes.IProcessRunner.Kill">
            <summary> Kills the process if it is still running </summary>
        </member>
        <member name="M:Mozart.Processes.IProcessRunner.WaitForExit">
            <summary> Closes std::in and waits for the process to exit </summary>
        </member>
        <member name="M:Mozart.Processes.IProcessRunner.WaitForExit(System.TimeSpan)">
            <summary> Closes std::in and waits for the process to exit, returns false if the process did not exit in the time given </summary>
        </member>
        <member name="P:Mozart.Processes.IProcessRunner.WorkingDirectory">
            <summary> Gets or sets the initial working directory for the process. </summary>
        </member>
        <member name="M:Mozart.Processes.IProcessRunner.Run">
            <summary> Runs the process and returns the exit code. </summary>
        </member>
        <member name="M:Mozart.Processes.IProcessRunner.Run(System.String[])">
            <summary> Runs the process and returns the exit code. </summary>
        </member>
        <member name="M:Mozart.Processes.IProcessRunner.Run(System.IO.TextReader,System.String[])">
            <summary> Runs the process and returns the exit code. </summary>
        </member>
        <member name="M:Mozart.Processes.IProcessRunner.Start">
            <summary> Starts the process and returns. </summary>
        </member>
        <member name="M:Mozart.Processes.IProcessRunner.Start(System.String[])">
            <summary> Starts the process and returns. </summary>
        </member>
        <member name="T:Mozart.Processes.ProcessExitedEventHandler">
            <summary>
            Raised when a process started with the ProcessRunner exits
            </summary>
        </member>
        <member name="T:Mozart.Processes.ProcessExitedEventArgs">
            <summary>
            Carries the exit code of the exited process.
            </summary>
        </member>
        <member name="P:Mozart.Processes.ProcessExitedEventArgs.ExitCode">
            <summary>
            Returns the environment exit code of the process
            </summary>
        </member>
        <member name="T:Mozart.Processes.ProcessOutputEventHandler">
            <summary> A delegate that handles the write to either std::out or std::in for a process </summary>
        </member>
        <member name="T:Mozart.Processes.ProcessOutputEventArgs">
            <summary> 
            The event args that contains information about the line of text written to either
            std::out or std::in on the created process. 
            </summary>
        </member>
        <member name="P:Mozart.Processes.ProcessOutputEventArgs.Data">
            <summary> Returns the line of text written to standard out/error  </summary>
        </member>
        <member name="P:Mozart.Processes.ProcessOutputEventArgs.IsError">
            <summary> Returns true if the line of text was written to std::error </summary>
        </member>
        <member name="T:Mozart.Processes.ProcessRunner">
            <summary>
            Creates/Spawns a process with the standard error/out/in all mapped.  Subscribe to
            the OutputReceived event prior to start/run to listen to the program output, write
            to the StandardInput for input.
            </summary>
        </member>
        <member name="M:Mozart.Processes.ProcessRunner.#ctor(System.String)">
            <summary>Creates a ProcessRunner for the given executable </summary>
        </member>
        <member name="M:Mozart.Processes.ProcessRunner.#ctor(System.String,System.String[])">
            <summary>Creates a ProcessRunner for the given executable and arguments </summary>
        </member>
        <member name="M:Mozart.Processes.ProcessRunner.Dispose">
            <summary> Detaches event handlers and closes input streams </summary>
        </member>
        <member name="M:Mozart.Processes.ProcessRunner.ToString">
            <summary> Returns a debug-view string of process/arguments to execute </summary>
        </member>
        <member name="E:Mozart.Processes.ProcessRunner.OutputReceived">
            <summary> Notifies caller of writes to the std::err or std::out </summary>
        </member>
        <member name="E:Mozart.Processes.ProcessRunner.ProcessExited">
            <summary> Notifies caller when the process exits </summary>
        </member>
        <member name="P:Mozart.Processes.ProcessRunner.StandardInput">
            <summary> Allows writes to the std::in for the process </summary>
        </member>
        <member name="P:Mozart.Processes.ProcessRunner.WorkingDirectory">
            <summary> Gets or sets the initial working directory for the process. </summary>
        </member>
        <member name="P:Mozart.Processes.ProcessRunner.ExitCode">
            <summary> Waits for the process to exit and returns the exit code </summary>
        </member>
        <member name="M:Mozart.Processes.ProcessRunner.Kill">
            <summary> Kills the process if it is still running </summary>
        </member>
        <member name="M:Mozart.Processes.ProcessRunner.WaitForExit">
            <summary> Closes std::in and waits for the process to exit </summary>
        </member>
        <member name="M:Mozart.Processes.ProcessRunner.WaitForExit(System.TimeSpan)">
            <summary> Closes std::in and waits for the process to exit, returns false if the process did not exit in the time given </summary>
        </member>
        <member name="M:Mozart.Processes.ProcessRunner.WaitForExit(System.TimeSpan,System.Boolean)">
            <summary> Waits for the process to exit, returns false if the process did not exit in the time given </summary>
        </member>
        <member name="P:Mozart.Processes.ProcessRunner.IsRunning">
            <summary> Returns true if this instance is running a process </summary>
        </member>
        <member name="M:Mozart.Processes.ProcessRunner.Run">
            <summary> Runs the process and returns the exit code. </summary>
        </member>
        <member name="M:Mozart.Processes.ProcessRunner.Run(System.String[])">
            <summary> Runs the process with additional arguments and returns the exit code. </summary>
        </member>
        <member name="M:Mozart.Processes.ProcessRunner.Run(System.IO.TextReader,System.String[])">
            <summary> Runs the process with additional arguments and returns the exit code. </summary>
        </member>
        <member name="M:Mozart.Processes.ProcessRunner.RunFormatArgs(System.Object[])">
            <summary> 
            Calls String.Format() for each argument this runner was constructed with giving the object
            array as the arguments.  Once complete it runs the process with the new set of arguments and
            returns the exit code.
            </summary>
        </member>
        <member name="M:Mozart.Processes.ProcessRunner.Start">
            <summary> Starts the process and returns. </summary>
        </member>
        <member name="M:Mozart.Processes.ProcessRunner.Start(System.String[])">
            <summary> Starts the process with additional arguments and returns. </summary>
        </member>
        <member name="M:Mozart.Processes.ProcessRunner.StartFormatArgs(System.Object[])">
            <summary> 
            Calls String.Format() for each argument this runner was constructed with giving the object
            array as the arguments.  Once complete it starts the process with the new set of arguments and
            returns.
            </summary>
        </member>
        <member name="T:Mozart.Processes.ScriptEngine">
            <summary>
            Defines the information needed to run various types of scripts on a Windows host
            </summary>
        </member>
        <member name="T:Mozart.Processes.ScriptEngine.Language">
            <summary>
            Defines the languages we know how to run, or 'Other' when user-defined
            </summary>
        </member>
        <member name="F:Mozart.Processes.ScriptEngine.Language.JScript">
            <summary> .JS Javascript file </summary>
        </member>
        <member name="F:Mozart.Processes.ScriptEngine.Language.VBScript">
            <summary> .VBS VBScript file </summary>
        </member>
        <member name="F:Mozart.Processes.ScriptEngine.Language.Cmd">
            <summary> .CMD Shell Script </summary>
        </member>
        <member name="F:Mozart.Processes.ScriptEngine.Language.PowerShell">
            <summary> PowerShell (v2, or v1) </summary>
        </member>
        <member name="F:Mozart.Processes.ScriptEngine.Language.CSharp">
            <summary> .CS C# Program </summary>
        </member>
        <member name="F:Mozart.Processes.ScriptEngine.Language.VBNet">
            <summary> Visual Basic .Net Program </summary>
        </member>
        <member name="F:Mozart.Processes.ScriptEngine.Language.Exe">
            <summary> The script is an executable's path </summary>
        </member>
        <member name="T:Mozart.Processes.ScriptEngine.Options">
            <summary>
            Options for script execution
            </summary>
        </member>
        <member name="F:Mozart.Processes.ScriptEngine.Options.None">
            <summary></summary>
        </member>
        <member name="F:Mozart.Processes.ScriptEngine.Options.UsesStandardInputScript">
            <summary> Sends the script to the process via std::in rather than using a temp file </summary>
        </member>
        <member name="M:Mozart.Processes.ScriptEngine.GetDefaults(Mozart.Processes.ScriptEngine.Language)">
            <summary>
            Returns the default execution options for the specified scripting type
            </summary>
        </member>
        <member name="P:Mozart.Processes.ScriptEngine.ScriptType">
            <summary> Returns the type/language of the script </summary>
        </member>
        <member name="P:Mozart.Processes.ScriptEngine.Executable">
            <summary> The script engine executable </summary>
        </member>
        <member name="P:Mozart.Processes.ScriptEngine.ArgumentFormat">
            <summary> The arguments to run the script </summary>
        </member>
        <member name="P:Mozart.Processes.ScriptEngine.FileExtension">
            <summary> The file extension of the script </summary>
        </member>
        <member name="P:Mozart.Processes.ScriptEngine.RunOptions">
            <summary> The run options </summary>
        </member>
        <member name="M:Mozart.Processes.ScriptEngine.Compile(System.String)">
            <summary> Preprocessing/Compiler routine </summary>
        </member>
        <member name="P:Mozart.Processes.ScriptEngine.UsesStandardInputScript">
            <summary>
            Returns true if the script should be fed into the std::in stream of the script process
            </summary>
        </member>
        <member name="T:Mozart.Processes.ScriptRunner">
            <summary>
            Defines a way to run scripts as an external process and capture their output.
            </summary>
        </member>
        <member name="M:Mozart.Processes.ScriptRunner.#ctor(Mozart.Processes.ScriptEngine.Language,System.String)">
            <summary>
            Creates a runnable script with the specified language
            </summary>
        </member>
        <member name="M:Mozart.Processes.ScriptRunner.#ctor(Mozart.Processes.ScriptEngine,System.String)">
            <summary>
            Creates a runnable script with the specified engine parameters
            </summary>
        </member>
        <member name="P:Mozart.Processes.ScriptRunner.ScriptEngine">
            <summary> Return teh script engine being used </summary>
        </member>
        <member name="P:Mozart.Processes.ScriptRunner.ScriptArguments">
            <summary> Return teh arguments to pass to script engine exe </summary>
        </member>
        <member name="P:Mozart.Processes.ScriptRunner.ScriptFile">
            <summary> Returns the temp file of the script </summary>
        </member>
        <member name="M:Mozart.Processes.ScriptRunner.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Mozart.Processes.ScriptRunner.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
        </member>
        <member name="E:Mozart.Processes.ScriptRunner.OutputReceived">
            <summary> Notifies caller of writes to the std::err or std::out </summary>
        </member>
        <member name="E:Mozart.Processes.ScriptRunner.ProcessExited">
            <summary> Notifies caller when the process exits </summary>
        </member>
        <member name="P:Mozart.Processes.ScriptRunner.StandardInput">
            <summary> Allows writes to the std::in for the process </summary>
        </member>
        <member name="P:Mozart.Processes.ScriptRunner.ExitCode">
            <summary> Waits for the process to exit and returns the exit code </summary>
        </member>
        <member name="P:Mozart.Processes.ScriptRunner.WorkingDirectory">
            <summary> Gets or sets the initial working directory for the process. </summary>
        </member>
        <member name="P:Mozart.Processes.ScriptRunner.IsRunning">
            <summary> Returns true if this instance is running a process </summary>
        </member>
        <member name="M:Mozart.Processes.ScriptRunner.Kill">
            <summary> Kills the process if it is still running </summary>
        </member>
        <member name="M:Mozart.Processes.ScriptRunner.WaitForExit">
            <summary> Closes std::in and waits for the process to exit </summary>
        </member>
        <member name="M:Mozart.Processes.ScriptRunner.WaitForExit(System.TimeSpan)">
            <summary> Closes std::in and waits for the process to exit, returns false if the process did not exit in the time given </summary>
        </member>
        <member name="M:Mozart.Processes.ScriptRunner.Run">
            <summary> Runs the process and returns the exit code. </summary>
        </member>
        <member name="M:Mozart.Processes.ScriptRunner.Run(System.String[])">
            <summary> Runs the process and returns the exit code. </summary>
        </member>
        <member name="M:Mozart.Processes.ScriptRunner.Run(System.IO.TextReader,System.String[])">
            <summary> Runs the process and returns the exit code. </summary>
        </member>
        <member name="M:Mozart.Processes.ScriptRunner.Start">
            <summary> Runs the process and returns the exit code. </summary>
        </member>
        <member name="M:Mozart.Processes.ScriptRunner.Start(System.String[])">
            <summary> Starts the process and returns. </summary>
        </member>
        <member name="T:Mozart.CoreResources">
            <summary>
              지역화된 문자열 등을 찾기 위한 강력한 형식의 리소스 클래스입니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.ResourceManager">
            <summary>
              이 클래스에서 사용하는 캐시된 ResourceManager 인스턴스를 반환합니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Culture">
            <summary>
              이 강력한 형식의 리소스 클래스를 사용하여 모든 리소스 조회에 대해 현재 스레드의 CurrentUICulture 속성을
              재정의합니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.CannotModifyCollection">
            <summary>
              The \&quot;{0}\&quot; collection is read-only and cannot be modified.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.CollectionIsEmpty">
            <summary>
              The supplied collection should contain atleast one element.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.ConfigurationInvalidValueAttributes">
            <summary>
              No valid attributes were found to construct the value for the {0}. Please check the configuration file.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.ConfigurationRequiredPropertyMissing">
            <summary>
              The attribute {0} must be present and non-empty.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.ExceptionConfigurationFileNotFound">
            <summary>
              The section {0} could not be saved because the file does not exist.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.ExceptionEntryNotPersisted">
            <summary>
              Invalid operation on entry that is not persisted.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.ExceptionInvalidCallbackCombination">
            <summary>
              Only one callback can be specified.  Either RemovedCallback or UpdateCallback must be null.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.ExceptionInvalidExpirationCombination">
            <summary>
              AbsoluteExpiration must be DateTimeOffset.MaxValue or SlidingExpiration must be TimeSpan.Zero.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.ExceptionPercentOfQuotaRangeComparison">
            <summary>
              The percentOfQuotaUsedBeforeScavenging threshold value ({0:F2}) cannot be lower than the percentOfQuotaUsedAfterScavenging threshold value ({1:F2}).과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.ExceptionScriptEvaluatorInvalidArgument">
            <summary>
              Script evaluator exception: invalid argument at position {1}.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.ExceptionScriptEvaluatorLanguageNotSupported">
            <summary>
              Script evaluator exception: language &apos;{1}&apos; is not supported.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.ExceptionScriptEvaluatorScriptControlNotInstalled">
            <summary>
              Script evaluator exception: the Windows Script Control does not seem to be installed and is a required component. Consult http://www.microsoft.com/downloads/details.aspx?FamilyId=D7E31492-2595-49E6-8C02-1426FEC693AC to download and install it.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.ExceptionScriptEvaluatorScriptControlNotInstalled2">
            <summary>
              Script evaluator exception: the Windows Script Control is not supported in a 64-bit process.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.InvalidFileExtension">
            <summary>
              Invalid file extension: &apos;{0}&apos;.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.InvalidValueForEnumType">
            <summary>
              The value {0} is invalid for Enum-type {1}.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_AmbiguousInjectionConstructor">
            <summary>
              The type {0} has multiple constructors of length {1}. Unable to disambiguate.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_AppendingRegistrationsToContainerUncontrolledCollectionsIsNotSupported">
            <summary>
              You are trying to append a registration to the registered collection of {0} instances, which is either registered using RegisterMultiple&lt;TService&gt;(IEnumerable&lt;TService&gt;) or  RegistereAll(Type, IEnumerable). Since the number of returned items might change on each call, appending registrations to these collections is not supported. Please register the collection with one of the other RegisterMultiple overloads is appending is required.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_CanNotDecorateContainerUncontrolledCollection">
            <summary>
              You are trying to apply the {0} decorator with the &apos;{1}&apos; lifecycle to a collection of type {2}, but the registered collection is not controlled by the container. Since the number of returned items might change on each call, the decorator with this lifecycle cannot be applied to the collection. Instead, register the decorator with the Transient lifecycle, or use one of the RegisterMultiple overloads that takes a collection of System.Type types.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_CannotInjectGenericMethod">
            <summary>
              The method {0}.{1}({2}) is an open generic method. Open generic methods cannot be injected.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_CannotInjectIndexer">
            <summary>
              The property {0} on type {1} is an indexer. Indexed properties cannot be injected.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_CannotInjectMethodWithOutParams">
            <summary>
              The method {0}.{1}({2}) has at least one out parameter. Methods with out parameters cannot be injected.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_CannotInjectMethodWithRefParams">
            <summary>
              The method {0}.{1}({2}) has at least one ref parameter.Methods with ref parameters cannot be injected.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_CannotInjectStaticMethod">
            <summary>
              The method {0}.{1}({2}) is static. Static methods cannot be injected.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_CantGenerateFuncForDecorator">
            <summary>
              It&apos;s impossible for the container to generate a Func&lt;{0}&gt; for injection into the {1} decorator, that will be wrapped around instances of the collection of {0} instances, because the registration hasn&apos;t been made using one of the RegisterMultiple overloads that take a list of System.Type as serviceTypes. By passing in an IEnumerable&lt;{0}&gt; it is impossible for the container to determine its lifecycle, which makes it impossible to generate a Func&lt;T&gt;. Either switch to one of the other RegisterMultiple overloads,[나머지 문자열은 잘림]&quot;;과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_CollectionTypeAlreadyRegistered">
            <summary>
              Collection of items for type {0} has already been registeredand and the container is currently not configured to allow overriding registrations. To allow overriding the current registration, please create the container using the constructor overload that takes a {1} instance and set the AllowOverridingRegistrations property to true.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConfigurationCannotCreateContainerConfiguringElement">
            <summary>
              An abstract ContainerConfiguringElement cannot be created. Please specify a concrete type.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConfigurationCannotCreateInjectionMemberElement">
            <summary>
              An abstract InjectionMemberElement object cannot be created. Please specify a concrete type.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConfigurationCannotCreateParameterValueElement">
            <summary>
              An abstract ParameterValueElement object cannot be created. Please specify a concrete type.&lt;과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConfigurationCouldNotResolveType">
            <summary>
              The type name or alias {0} could not be resolved. Please check your configuration file and verify this type name.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConfigurationDependencyForOptionalGenericParameterWithTypeSet">
            <summary>
              The optional dependency element for generic parameter {0} must not have an explicit type name but has &apos;{1}&apos;.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConfigurationDuplicateParameterValueElement">
            <summary>
              The injection configuration for {0} has multiple values.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConfigurationElementTypeNotRegistered">
            <summary>
              The configuration element type {0} has not been registered with the section.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConfigurationElementWithAttributesAndParameterValueElements">
            <summary>
              The injection configuration for {0} is specified through both attributes and child value elements.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConfigurationExtensionTypeNotFound">
            <summary>
              Could not load section extension type {0}.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConfigurationInvalidCollectionContainsNullElements">
            <summary>
              The configuration is invalid. One of the items in the collection for type {0} is a null reference.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConfigurationInvalidCreatingInstanceFailed">
            <summary>
              The configuration is invalid. Creating the instance for type {0} failed. {1}과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConfigurationInvalidExtensionElementType">
            <summary>
              The extension element type {0} that is being added does not derive from ContainerConfiguringElement, InjectionMemberElement, or ParameterValueElement. An extension element must derive from one of these types.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConfigurationInvalidIteratingCollectionFailed">
            <summary>
              The configuration is invalid. Iterating the collection for type {0} failed. {1}과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConfigurationNoMatchingConstructor">
            <summary>
              Configuration is incorrect, the type {0} does not have a constructor that takes parameters named {1}.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConfigurationNoMatchingMethod">
            <summary>
              Configuration is incorrect, the type {0} does not have a method named {1} that takes parameters named {2}.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConfigurationNoSuchContainer">
            <summary>
              The container named &quot;{0}&quot; is not defined in this configuration section.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConfigurationNoSuchProperty">
            <summary>
              The type {0} does not have a property named {1}.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConfigurationNotAnArray">
            <summary>
              The configuration is set to inject an array, but the type {0} is not an array type.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConstructorInjectionBehaviorReturnedNull">
            <summary>
              The {0} that was registered through Container.Options.ConstructorInjectionBehavior returned a null reference after its BuildParameterExpression(ParameterInfo) method was supplied with the argument of type {1} with name &apos;{2}&apos; from the constructor of type {3}. {4}.BuildParameterExpression implementations should never return null, but should throw an {5} with an expressive message instead.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ConstructorMustNotContainInvalidParameter">
            <summary>
              The constructor of type {0} contains parameter &apos;{1}&apos; of type {2} which can not be used for constructor injection{3}.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ContainerCanNotBeChangedAfterUse">
            <summary>
              The container can&apos;t be changed after the first call to GetInstance, GetAllInstances and Verify.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ContainerOptionsBelongsToAnotherContainer">
            <summary>
              The supplied ContainerOptions instance belongs to another Container instance. Create a new ContainerOptions per Container instance.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ContainerOptionsNotPartOfContainer">
            <summary>
              The ContainerOptions instance for this ConstructorInjectionBehavior is not part of a Container instance. Please make sure the ContainerOptions instance is supplied as argument to the constructor of a Container.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_CtorParameterTypeMustBeRegistered">
            <summary>
              The constructor of the type {3} contains the parameter of type {0} with name &apos;{1}&apos; that is not registered. Please ensure {0} is registered in the container, or change the constructor of {2}.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_DecoratorCanNotBeAGenericTypeDefinitionWhenServiceTypeIsNot">
            <summary>
              The supplied decorator {0} is an open generic type definition, while the supplied service type {1} is not.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_DecoratorContainsUnresolvableTypeArguments">
            <summary>
              The supplied decorator {0} contains unresolvable type arguments. The type would never be resolved and is therefore not suited to be used as decorator.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_DelegateForTypeReturnedNull">
            <summary>
              The registered delegate for type {0} returned null.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_DelegateForTypeThrewAnException">
            <summary>
              The registered delegate for type {0} threw an exception.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ErrorInRegisterOpenGenericRegistration">
            <summary>
              There was an error in the registration of open generic type {0}. Failed to build a registration for type {1}. {2}과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ErrorWhileBuildingDelegateFromExpression">
            <summary>
              Error occurred while trying to build a delegate for type {0} using the expression &quot;{1}&quot;. {2}과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ImplicitRegistrationCouldNotBeMadeForType">
            <summary>
              No registration for type {0} could be found and an implicit registration could not be made.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_MethodParameterTypeMustBeRegistered">
            <summary>
              The method of the type {3} contains the parameter of type {0} with name &apos;{1}&apos; that is not registered. Please ensure {0} is registered in the container, or change the method of {2}.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_MultipleInjectionConstructors">
            <summary>
              The type {0} has multiple constructors marked with the InjectionConstructor attribute. Unable to disambiguate.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_MultipleObserversRegisteredTheSameTypeToResolveUnregisteredType">
            <summary>
              Multiple observers of the ResolveUnregisteredType event are registering a delegate for the same service type: {0}. Make sure only one of the registered handlers calls the ResolveUnregisteredType.Register method for a given service type.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_MultipleTypesThatRepresentClosedGenericType">
            <summary>
              There are {0} types that represent the closed generic type {1}. Types: {2}. Either remove one of the types or use an overload that takes an {3} delegate, which allows you to define the way these types should be registered.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_MustContainASingleInstanceOfTheServiceTypeAsArgument">
            <summary>
              For the container to be able to use {0} as a decorator, its constructor must include a single parameter of type {1} (or Func&lt;{1}&gt;) - i.e. the type of the instance that is being decorated. The parameter type {1} is defined multiple times in the constructor of class {0}.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_MustContainTheServiceTypeAsArgument">
            <summary>
              For the container to be able to use {0} as a decorator, its constructor must include a single parameter of type {1} (or Func&lt;{1}&gt;) - i.e. the type of the instance that is being decorated. The parameter type {1} does not currently exist in the constructor of class {0}.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_NoMatchingGenericArgument">
            <summary>
              The type {0} does not have a generic argument named &quot;{1}&quot;과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_NoRegistrationForPropertyFound">
            <summary>
              Property of type {0} with name &apos;{1}&apos; can&apos;t be injected, because no registration for type {2} could be found. {3}과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_NoRegistrationForTypeFound">
            <summary>
              No registration for type {0} could be found.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_NoSuchConstructor">
            <summary>
              The type {0} does not have a constructor that takes the parameters ({1}).과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_NoSuchMethod">
            <summary>
              The type {0} does not have a public method named {1} that takes the parameters ({2}).과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_NoSuchProperty">
            <summary>
              The type {0} does not contain an instance property named {1}.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_NotAGenericType">
            <summary>
              The type {0} is not a generic type, and you are attempting to inject a generic parameter named &quot;{1}&quot;.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_NullParameterValue">
            <summary>
              Parameter type inference does not work for null values. Indicate the parameter type explicitly using a properly configured instance of the InjectionParameter or InjectionParameter&amp;lt;T&amp;gt; classes.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_PropertyCanNotBeChangedAfterTheFirstRegistration">
            <summary>
              The &apos;{0}&apos; property cannot be changed after the first registration has been made to the container.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_PropertyHasNoSetter">
            <summary>
              The property named &apos;{0}&apos; with type {1} and declared on type {2} can&apos;t be injected, because it has no set method.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_PropertyIsStatic">
            <summary>
              Property of type {0} with name &apos;{1}&apos; can&apos;t be injected, because it is static.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_PropertyTypeMismatch">
            <summary>
              The property {0} on type {1} is of type {2}, and cannot be injected with a value of type {3}.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_RegisterationNotAllowOpenGenerics">
            <summary>
              The supplied list of types contains an open generic type, but this overloaded method is unable to handle open generic types because this overload can only register closed generic services types that have a single implementation. Please use the overload that takes in the {0} instead. Invalid types: {1}.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_RegistrationBelongsToADifferentContainer">
            <summary>
              The supplied Registration belongs to a different container.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_RegistrationReturnedNullFromBuildExpression">
            <summary>
              The {0} for the {1} returned a null reference from its BuildExpression method.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_SuppliedTypeCanNotBeOpenWhenDecoratorIsClosed">
            <summary>
              Registering a closed generic service type with an open generic decorator is not supported. Instead, register the service type as open generic, and the decorator as closed generic type.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_SuppliedTypeIsAnOpenGenericType">
            <summary>
              The supplied type {0} is an open generic type. This type cannot be used for registration using this method. You can use one of the {1}.RegisterOpenGeneric extension method overloads for mapping an generic abstraction to an generic implementation, or use one of the {2}.RegisterManyForOpenGeneric extension method overloads for registering a set of implementations for a generic abstraction.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_SuppliedTypeIsNotAnOpenGenericType">
            <summary>
              The supplied type {0} is not an open generic type.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_SuppliedTypeIsNotAReferenceType">
            <summary>
              The supplied type {0} is not a reference type. Only reference types are supported.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_TheConstructorOfTypeMustContainTheServiceTypeAsArgument">
            <summary>
              For the container to be able to use {0} as a decorator, its constructor should have an argument of one of the following types: {1}.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_TheInitializersCouldNotBeApplied">
            <summary>
              The initializer(s) for type {0} could not be applied. {1}과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_TypeAlreadyRegistered">
            <summary>
              Type {0} has already been registered and the container is currently not configured to allow overriding registrations. To allow overriding the current registration, please set the Container.Options.AllowOverridingRegistrations to true.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_TypeDependsOnItself">
            <summary>
              The configuration is invalid. The type {0} is directly or indirectly depending on itself.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_TypeIsAmbiguous">
            <summary>
              You are trying to register {0} as a service type, but registering this type is not allowed to be registered because the type is ambiguous. The registration of such a type almost always indicates a flaw in the design of the application and is therefore not allowed. Please change any component that depends on a dependency of this type. Ensure that the container does not have to inject any dependencies of this type by injecting a different type.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_TypeMustHaveASinglePublicConstructor">
            <summary>
              For the container to be able to create {0}, it should contain exactly one public constructor, but it has {1}.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_TypesAreNotAssignable">
            <summary>
              The type {1} cannot be assigned to variables of type {0}.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_TypeShouldBeConcreteToBeUsedOnThisMethod">
            <summary>
              The given type {0} is not a concrete type. Please use one of the other overloads to register this type.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_UnableToInjectImplicitPropertiesDueToSecurityConfiguration">
            <summary>
              Unable to inject properties into type {0}. The security restrictions of your application&apos;s sandbox do not permit the creation of one of its dependencies. Explicitly register that dependency using one of the generic &apos;Register&apos; overloads or consider making it public. {1}과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_UnableToInjectPropertiesDueToSecurityConfiguration">
            <summary>
              Unable to inject properties into type {0}. The security restrictions of your application&apos;s sandbox do not permit the injection of one of its properties. Consider making it public. {1}과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_UnableToResolveTypeDueToSecurityConfiguration">
            <summary>
              Unable to resolve type {0}. The security restrictions of your application&apos;s sandbox do not permit the creation of this type. Explicitly register the type using one of the generic &apos;Register&apos; overloads or consider making it public. {1}과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ValueNotAllowedForGenericArrayType">
            <summary>
              The value element for {1} was specified for the generic array type {0}. Value elements are not allowed for generic array types.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ValueNotAllowedForGenericParameterType">
            <summary>
              The value element for {1} was specified for the generic parameter type {0}. Value elements are not allowed for generic parameter types.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Ioc_ValueNotAllowedForOpenGenericType">
            <summary>
              The value element for {1} was specified for the generic type {0}. Value elements are not allowed for generic types.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.ItemsLeftAfterScavengingMustBePositive">
            <summary>
              The number of items left in the cache after scavenging must be greater than zero.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.ItemsLeftMustBeLessThanMaxItemsBefore">
            <summary>
              The number of items left in the cache after scavenging must be less than or equal to the number of items allowed before scavenging.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.MaxItemsBeforeScavengingMustBePositive">
            <summary>
              The number of items allowed in the cache before scavenging happens must be greater than zero.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.MustOverrideIndexerGet">
            <summary>
              The get accessor of the indexer must be overridden.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.MustOverrideIndexerSet">
            <summary>
              The set accessor of the indexer must be overridden.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.MustOverrideOrReimplement">
            <summary>
              This method must be overridden or re-implemented in the derived class.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.PropertyNotSettable">
            <summary>
              The property {0} on type {1} is not settable.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Reflector_SetInvalidValue">
            <summary>
              The &apos;{2}&apos; property on &apos;{1}&apos; could not be set to a &apos;{3}&apos; value. You must set this property to a non-null value of type &apos;{0}&apos;.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.RegionsNotSupported">
            <summary>
              This cache object does not support regions.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Serializer_ValueLengthDoesNotMatchMetadata">
            <summary>
              The serialized value is invalid: serialized value length is different than the logical size.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.Serializer_ValueTooShort">
            <summary>
              The serialized value is invalid: too short.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.SerializerType_DerivedTypeNotCorrect">
            <summary>
              SerializerType value must be a type that implements IIsolatedStorageCacheEntrySerializer and has a default constructor.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:Mozart.CoreResources.SuppliedTypeDoesNotAssignable">
            <summary>
              The supplied type {0} does not assignable from {1}.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="T:Mozart.Utility.ObjectKeepAlive">
            <summary>
            Provides a means of forcing the garbage collector to wait on objects aquired from permanent 
            storage while only holding WeakReference's of the object.  Essentially uses a simple lockless 
            algorithm to track the most recently loaded objects so that they will stay alive longer.
            </summary>
        </member>
        <member name="M:Mozart.Utility.ObjectKeepAlive.#ctor(System.Int32,System.Int32,System.TimeSpan)">
            <summary>
            Configures the keep-alive policy for this container
            </summary>
            <param name="minItems">The minimum number of items desired in the list (kept event after age expires)</param>
            <param name="maxItems">The maximum number of items desired in the list (discarded even if age has not expired)</param>
            <param name="maxAge">Determines how long to keep an object if the count is between min and max</param>
        </member>
        <member name="M:Mozart.Utility.ObjectKeepAlive.#ctor(System.Int32,System.Int32,System.TimeSpan,System.Boolean)">
            <summary>
            Configures the keep-alive policy for this container
            </summary>
            <param name="minItems">The minimum number of items desired in the list (kept event after age expires)</param>
            <param name="maxItems">The maximum number of items desired in the list (discarded even if age has not expired)</param>
            <param name="maxAge">Determines how long to keep an object if the count is between min and max</param>
            <param name="externalTicks">True if you want to perform cleanup exclusivly on another thread by calling Tick(), otherwise false</param>
        </member>
        <member name="M:Mozart.Utility.ObjectKeepAlive.Clear">
            <summary>
            Clears the entire keep-alive cache
            </summary>
        </member>
        <member name="M:Mozart.Utility.ObjectKeepAlive.Tick">
            <summary>
            Can be called periodically by external threads to ensure cleanup instead of depending upon calls to Add()
            </summary>
        </member>
        <member name="M:Mozart.Utility.ObjectKeepAlive.Add(System.Object)">
            <summary>
            Cleans up expired items and adds the object to the list of items to keep alive.
            </summary>
        </member>
        <member name="M:Mozart.Utility.ObjectUtility.Compare(System.Object,System.Object)">
            <summary>Compares two objects.</summary>
            <param name="first">First object.</param>
            <param name="second">Second object.</param>
            <returns>
            0, if objects are equal; 
            less than zero, if the first object is smaller than the second one;
            greater than zero, if the first object is greater than the second one.</returns>
        </member>
        <member name="M:Mozart.Utility.ObjectUtility.CoerceTypes(System.Object@,System.Object@)">
            <summary>
            Coerces the types so they can be compared.
            </summary>
            <param name="m">The left.</param>
            <param name="n">The right.</param>
        </member>
        <member name="M:Mozart.Utility.ObjectUtility.IsNumber(System.Object)">
            <summary>
            Determines whether the supplied <paramref name="number"/> is of numeric type.
            </summary>
            <param name="number">The object to check.</param>
            <returns>
            	<c>true</c> if the specified object is of numeric type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Mozart.Utility.ProcessInformation">
            <summary>
            Utility class for obtaining information about the currently running
            process and AppDomain
            </summary>
        </member>
        <member name="F:Mozart.Utility.ProcessInformation.UNKNOWN">
            <summary> Returns the string '[Unknown]'</summary>
        </member>
        <member name="F:Mozart.Utility.ProcessInformation.ProcessId">
            <summary> Returns the current process id </summary>
        </member>
        <member name="F:Mozart.Utility.ProcessInformation.ProcessName">
            <summary> Returns the current process name without an extension </summary>
        </member>
        <member name="F:Mozart.Utility.ProcessInformation.ProcessFile">
            <summary> Returns the file path to the exe for this process </summary>
        </member>
        <member name="F:Mozart.Utility.ProcessInformation.AppDomainName">
            <summary> Returns the current AppDomain's friendly name </summary>
        </member>
        <member name="F:Mozart.Utility.ProcessInformation.EntryAssembly">
            <summary> Returns the entry-point assembly or the highest stack assembly </summary>
        </member>
        <member name="F:Mozart.Utility.ProcessInformation.ProductVersion">
            <summary> Returns the product version of the entry assembly </summary>
        </member>
        <member name="F:Mozart.Utility.ProcessInformation.ProductName">
            <summary> Returns the product name of the entry assembly </summary>
        </member>
        <member name="F:Mozart.Utility.ProcessInformation.CompanyName">
            <summary> Returns the company name of the entry assembly </summary>
        </member>
        <member name="F:Mozart.Utility.ProcessInformation.IsDebugging">
            <summary> Returns true if a debugger is attached to the process </summary>
        </member>
        <member name="F:Mozart.Utility.ProcessInformation.RegistrySoftwarePath">
            <summary>
            Returns the HKCU or HKLM path for this software application based
            on the process that is running: Software\{CompanyName}\{ProductName}
            </summary>
        </member>
        <member name="F:Mozart.Utility.ProcessInformation.ApplicationData">
            <summary>
            Returns the roaming user profile path for the currently running software
            application: {SpecialFolder.ApplicationData}\{CompanyName}\{ProductName}
            </summary>
        </member>
        <member name="F:Mozart.Utility.ProcessInformation.LocalApplicationData">
            <summary>
            Returns the non-roaming user profile path for the currently running software
            application: {SpecialFolder.LocalApplicationData}\{CompanyName}\{ProductName}
            </summary>
        </member>
        <member name="F:Mozart.Utility.ProcessInformation.DefaultLogFile">
            <summary>
            Returns a default log file name derived as:
            {SpecialFolder.LocalApplicationData}\{CompanyName}\{ProductName}\{AppDomainName}.txt
            </summary>
        </member>
        <member name="M:Mozart.Utility.ProcessInformation.#ctor">
            <summary>
            This is some ugly code, the intent is to be able to answer the above questions in 
            a wide array of environments.  I admit now this may fail eventually.
            </summary>
        </member>
        <member name="M:Mozart.Utility.ProcessInformation.SafeName(System.String)">
            <summary>
            Copy from StringUtils
            </summary>
        </member>
        <member name="T:Mozart.Utility.WeakReference`1">
            <summary>
            A strong-typed derivation of the WeakReference class
            </summary>
        </member>
        <member name="M:Mozart.Utility.WeakReference`1.#ctor(`0)">
            <summary> Creates a new WeakReference that keeps track of target. </summary>
        </member>
        <member name="M:Mozart.Utility.WeakReference`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary />
        </member>
        <member name="P:Mozart.Utility.WeakReference`1.IsAlive">
            <summary>
            Gets an indication whether the object referenced by the current object has been garbage collected.
            </summary>
        </member>
        <member name="P:Mozart.Utility.WeakReference`1.Target">
            <summary> Gets or sets the Object stored in the handle if it's accessible. </summary>
        </member>
        <member name="M:Mozart.Utility.WeakReference`1.TryGet(`0@)">
            <summary> Returns true if the Object was retrieved. </summary>
        </member>
        <member name="T:Mozart.Utility.ActiveScriptObject">
            <summary>
            Defines a pre-parsed script object that can be evaluated at runtime. 
            </summary>
        </member>
        <member name="T:Mozart.Utility.ActiveScript">
            <summary>
            Represents a Windows Script Engine such as JScript, VBScript, etc. 
            </summary>
        </member>
        <member name="T:Mozart.Utility.ActiveScriptShell">
            <summary>
            Shell for a Windows Script Engine such as JScript, VBScript, etc. 
            </summary>
        </member>
        <member name="T:Mozart.Utility.ActiveScriptException">
            <summary>
            Defines a Windows Script Engine exception. 
            </summary>
        </member>
        <member name="P:Mozart.Utility.ActiveScriptException.Number">
            <summary>
            Contains the error number
            </summary>
        </member>
        <member name="P:Mozart.Utility.ActiveScriptException.Line">
            <summary>
            Contains the source code line number where the error occurred
            </summary>
        </member>
        <member name="P:Mozart.Utility.ActiveScriptException.Column">
            <summary>
            Contains the source code column number where the error occurred
            </summary>
        </member>
        <member name="P:Mozart.Utility.ActiveScriptException.Description">
            <summary>
            Describes the error
            </summary>
        </member>
        <member name="P:Mozart.Utility.ActiveScriptException.Text">
            <summary>
            Contains the line of source code where the error occurred
            </summary>
        </member>
    </members>
</doc>
